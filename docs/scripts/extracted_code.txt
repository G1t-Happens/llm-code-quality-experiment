
===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/BaselineProjectApplication.java =====

1	package com.llmquality.baseline;
2	
3	import org.springframework.boot.SpringApplication;
4	import org.springframework.boot.autoconfigure.SpringBootApplication;
5	import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
6	
7	@SpringBootApplication
8	@EnableMethodSecurity
9	public class BaselineProjectApplication {
10	    public static void main(String[] args) {
11	        SpringApplication.run(BaselineProjectApplication.class, args);
12	    }
13	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/controller/AddressController.java =====

1	package com.llmquality.baseline.controller;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.dto.PagedResponse;
6	import com.llmquality.baseline.service.interfaces.AddressService;
7	import org.springframework.data.domain.Pageable;
8	import org.springframework.data.domain.Sort;
9	import org.springframework.data.web.PageableDefault;
10	import org.springframework.security.access.prepost.PreAuthorize;
11	import org.springframework.validation.annotation.Validated;
12	import org.springframework.web.bind.annotation.*;
13	
14	import static com.llmquality.baseline.dto.validation.AddressValidationGroups.*;
15	
16	
17	@RestController
18	@RequestMapping("${api.base-path}/users/{userId}/addresses")
19	public class AddressController {
20	
21	    private final AddressService addressService;
22	
23	    public AddressController(AddressService addressService) {
24	        this.addressService = addressService;
25	    }
26	
27	
28	    @GetMapping
29	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
30	    public PagedResponse<AddressResponse> listAll(
31	            @PathVariable Long userId,
32	            @PageableDefault(sort = "id", direction = Sort.Direction.ASC) Pageable pageable) {
33	        return addressService.listAll(userId, pageable);
34	    }
35	
36	    @GetMapping("/{addressId}")
37	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
38	    public AddressResponse getById(@PathVariable Long userId, @PathVariable Long addressId) {
39	        return addressService.getById(userId, addressId);
40	    }
41	
42	    @PostMapping
43	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
44	    public AddressResponse create(@PathVariable Long userId, @RequestBody @Validated(Create.class) AddressRequest addressRequest) {
45	        return addressService.save(userId, addressRequest);
46	    }
47	
48	    @PatchMapping("/{addressId}")
49	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
50	    public AddressResponse update(@PathVariable Long userId, @PathVariable Long addressId, @RequestBody @Validated(Update.class) AddressRequest addressRequest) {
51	        return addressService.update(userId, addressId, addressRequest);
52	    }
53	
54	    @DeleteMapping("/{addressId}")
55	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
56	    public void delete(@PathVariable Long userId, @PathVariable Long addressId) {
57	        addressService.delete(userId, addressId);
58	    }
59	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/controller/UserController.java =====

1	package com.llmquality.baseline.controller;
2	
3	import com.llmquality.baseline.dto.*;
4	import com.llmquality.baseline.service.interfaces.UserService;
5	import jakarta.validation.Valid;
6	import org.springframework.data.domain.Pageable;
7	import org.springframework.data.domain.Sort;
8	import org.springframework.data.web.PageableDefault;
9	import org.springframework.security.access.prepost.PreAuthorize;
10	import org.springframework.validation.annotation.Validated;
11	import org.springframework.web.bind.annotation.*;
12	
13	import static com.llmquality.baseline.dto.validation.UserValidationGroups.*;
14	
15	
16	@RestController
17	@RequestMapping("${api.base-path}/users")
18	public class UserController {
19	
20	    private final UserService userService;
21	
22	    public UserController(UserService userService) {
23	        this.userService = userService;
24	    }
25	
26	
27	    @GetMapping
28	    @PreAuthorize("hasRole('ADMIN')")
29	    public PagedResponse<UserResponse> listAll(@PageableDefault(sort = "id", direction = Sort.Direction.ASC) Pageable pageable) {
30	        return userService.listAll(pageable);
31	    }
32	
33	    @GetMapping("/{id}")
34	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#id, authentication)")
35	    public UserResponse getById(@PathVariable Long id) {
36	        return userService.getById(id);
37	    }
38	
39	    @GetMapping("/search")
40	    @PreAuthorize("hasRole('ADMIN')")
41	    public UserResponse getByUsername(@RequestParam("username") String username) {
42	        return userService.getByUsername(username);
43	    }
44	
45	    @PostMapping
46	    @PreAuthorize("hasRole('ADMIN') or @sec.canSetAdminFlag(#userRequest.admin, authentication)")
47	    public UserResponse create(@RequestBody @Validated(Create.class) UserRequest userRequest) {
48	        return userService.save(userRequest);
49	    }
50	
51	    @PatchMapping("/{id}")
52	    @PreAuthorize("hasRole('ADMIN') or (@sec.isOwner(#id, authentication) and @sec.canSetAdminFlag(#userRequest.admin, authentication))")
53	    public UserResponse update(@PathVariable Long id, @RequestBody @Validated(Update.class) UserRequest userRequest) {
54	        return userService.update(id, userRequest);
55	    }
56	
57	    @DeleteMapping("/{id}")
58	    @PreAuthorize("hasRole('ADMIN')")
59	    public void delete(@PathVariable Long id) {
60	        userService.delete(id);
61	    }
62	
63	    @PostMapping("/login")
64	    public LoginResponse login(@RequestBody @Valid LoginRequest loginRequest) {
65	        return userService.checkLogin(loginRequest);
66	    }
67	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/AddressRequest.java =====

1	package com.llmquality.baseline.dto;
2	
3	import com.llmquality.baseline.enums.AddressType;
4	import jakarta.validation.constraints.*;
5	
6	import static com.llmquality.baseline.dto.validation.AddressValidationGroups.*;
7	
8	
9	/**
10	 * Request DTO for addresses.
11	 * <p>
12	 * This is a Java {@code record}, which is immutable and automatically provides
13	 * a constructor, getter, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
14	 * Introduced in Java 17.
15	 * </p>
16	 */
17	public record AddressRequest(
18	
19	        @NotBlank(groups = Create.class, message = "Street is required on create")
20	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
21	                message = "Street must not be empty or consist only of whitespace")
22	        @Size(max = 255, message = "Street must be at most 255 characters long")
23	        String street,
24	
25	        @NotBlank(groups = Create.class, message = "House number is required on create")
26	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
27	                message = "House number must not be empty or consist only of whitespace")
28	        @Size(max = 255)
29	        String houseNumber,
30	
31	        @NotBlank(groups = Create.class, message = "Postal code is required on create")
32	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
33	                message = "Postal code must not be empty or consist only of whitespace")
34	        @Size(max = 255)
35	        String postalCode,
36	
37	        @NotBlank(groups = Create.class, message = "City is required on create")
38	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
39	                message = "City must not be empty or consist only of whitespace")
40	        @Size(max = 255)
41	        String city,
42	
43	        @NotBlank(groups = Create.class, message = "Country is required on create")
44	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
45	                message = "Country must not be empty or consist only of whitespace")
46	        @Size(max = 255)
47	        String country,
48	
49	        @NotNull(groups = Create.class, message = "Address type is required on create")
50	        AddressType addressType
51	) {
52	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
53	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/AddressResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	import com.llmquality.baseline.enums.AddressType;
4	
5	
6	/**
7	 * Response DTO for addresses.
8	 * <p>
9	 * This is a Java {@code record}, which is immutable and automatically provides
10	 * a constructor, getter, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
11	 * Introduced in Java 17.
12	 * </p>
13	 */
14	public record AddressResponse(
15	
16	        Long id,
17	
18	        String street,
19	
20	        String houseNumber,
21	
22	        String postalCode,
23	
24	        String city,
25	
26	        String country,
27	
28	        AddressType addressType,
29	
30	        Long userId
31	) {
32	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
33	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/LoginRequest.java =====

1	package com.llmquality.baseline.dto;
2	
3	import jakarta.validation.constraints.NotBlank;
4	import jakarta.validation.constraints.Size;
5	
6	
7	/**
8	 * Data Transfer Object (DTO) for user login requests.
9	 * <p>
10	 * Contains the username and password fields with validation constraints
11	 * to ensure non-blank input and enforce maximum length.
12	 * </p>
13	 */
14	public record LoginRequest(
15	
16	        @NotBlank(message = "Username must not be blank")
17	        @Size(max = 255, message = "Username must be at most 255 characters long")
18	        String username,
19	
20	        @NotBlank(message = "Password must not be blank")
21	        @Size(max = 255, message = "Password must be at most 255 characters long")
22	        String password
23	) {
24	    // You can add custom methods here if needed, e.g., convenience methods or formatting helpers.
25	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/LoginResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	
4	import java.time.Instant;
5	
6	/**
7	 * Response DTO for login operations.
8	 * <p>
9	 * This is a Java {@code record}, which is immutable and automatically provides
10	 * a constructor, getter, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
11	 * Introduced in Java 17.
12	 * </p>
13	 */
14	public record LoginResponse(
15	
16	        String token,
17	
18	        Instant expiresAt,
19	
20	        long expiresInSeconds
21	) {
22	    // You can add custom methods here if needed, e.g., convenience methods or formatting helpers.
23	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/PagedResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	import org.springframework.data.domain.Page;
4	
5	import java.util.Collections;
6	import java.util.List;
7	import java.util.Objects;
8	
9	
10	/**
11	 * Generic pagination DTO for REST API responses.
12	 *
13	 * <p>This DTO encapsulates paginated content along with metadata
14	 * about the current page, page size, total elements, total pages,
15	 * and whether the current page is the last one.</p>
16	 *
17	 * <p>This class provides a static factory method {@link #fromPage(Page)}
18	 * to easily convert a {@link Page} from Spring Data JPA into a stable
19	 * response structure suitable for REST APIs.</p>
20	 *
21	 * @param <T> the type of content in the page
22	 */
23	public record PagedResponse<T>(
24	
25	        List<T> content,
26	
27	        int page,
28	
29	        int size,
30	
31	        long totalElements,
32	
33	        int totalPages,
34	
35	        boolean last
36	) {
37	
38	    /**
39	     * Creates a {@code PagedResponse} from a Spring Data {@link Page}.
40	     *
41	     * @param page the {@link Page} containing content and pagination metadata
42	     * @param <T>  the type of the content
43	     * @return a new {@link PagedResponse} with content and pagination info
44	     */
45	    public static <T> PagedResponse<T> fromPage(Page<T> page) {
46	        Objects.requireNonNull(page, "Page must not be null");
47	        return new PagedResponse<>(
48	                Collections.unmodifiableList(page.getContent()),
49	                page.getNumber(),
50	                page.getSize(),
51	                page.getTotalElements(),
52	                page.getTotalPages(),
53	                page.isLast()
54	        );
55	    }
56	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/UserRequest.java =====

1	package com.llmquality.baseline.dto;
2	
3	import jakarta.validation.constraints.*;
4	
5	import static com.llmquality.baseline.dto.validation.UserValidationGroups.*;
6	
7	
8	/**
9	 * Data Transfer Object (DTO) for creating or updating a User.
10	 * <p>
11	 * Contains user input fields with validation annotations for create and update operations.
12	 * </p>
13	 */
14	public record UserRequest(
15	
16	        @NotBlank(groups = Create.class, message = "Username is required")
17	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
18	                message = "Username must not be empty or consist only of whitespace")
19	        String username,
20	
21	        @NotBlank(groups = Create.class, message = "Password is required on create")
22	        @Pattern(regexp = "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$",
23	                groups = {Create.class, Update.class},
24	                message = "Password must be at least 8 characters, contain number, lowercase and uppercase")
25	        @Size(min = 8, max = 255, groups = {Create.class, Update.class})
26	        String password,
27	
28	        @NotBlank(groups = Create.class, message = "Email is required on create")
29	        @Email(groups = {Create.class, Update.class}, message = "Invalid email format")
30	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
31	                message = "Email must not be empty or consist only of whitespace")
32	        String email,
33	
34	        @NotNull(groups = Create.class, message = "Admin flag is required on create")
35	        Boolean admin
36	) {
37	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
38	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/UserResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	
4	/**
5	 * Response DTO for User information.
6	 * <p>
7	 * This is a Java {@code record}, which is immutable and automatically provides
8	 * a constructor, getters, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
9	 * Introduced in Java 17.
10	 * </p>
11	 */
12	public record UserResponse(
13	
14	        Long id,
15	
16	        String username,
17	
18	        String email,
19	
20	        Boolean admin
21	
22	) {
23	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
24	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/validation/AddressValidationGroups.java =====

1	package com.llmquality.baseline.dto.validation;
2	
3	
4	/**
5	 * This class contains a validation group for differentiating between the
6	 * validation rules applied during the creation and update of a addresses.
7	 * <p>
8	 * These groups are used to apply specific validation constraints based on
9	 * the operation (create or update) being performed.
10	 * </p>
11	 *
12	 * <p>
13	 * The purpose of validation groups is to control which validation rules
14	 * are applied depending on the context, preventing unnecessary validations
15	 * for operations that don’t require them e.q. update requests
16	 * </p>
17	 */
18	public final class AddressValidationGroups {
19	
20	    /**
21	     * Private constructor to prevent instantiation of this utility class.
22	     * Throws UnsupportedOperationException if called.
23	     */
24	    private AddressValidationGroups() {
25	        throw new UnsupportedOperationException("Utility class - should not be instantiated");
26	    }
27	
28	    /**
29	     * Validation group for creating a new addresses.
30	     * <p>
31	     * This interface is used to mark the validation constraints that should
32	     * be applied when creating a new address.
33	     * </p>
34	     */
35	    public interface Create {
36	    }
37	
38	    /**
39	     * Validation group for updating an existing addresses.
40	     * <p>
41	     * This interface is used to mark the validation constraints that should
42	     * be applied when updating an address.
43	     * </p>
44	     */
45	    public interface Update {
46	    }
47	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/validation/UserValidationGroups.java =====

1	package com.llmquality.baseline.dto.validation;
2	
3	
4	/**
5	 * This class contains a validation group for differentiating between the
6	 * validation rules applied during the creation and update of a user.
7	 * <p>
8	 * These groups are used to apply specific validation constraints based on
9	 * the operation (create or update) being performed.
10	 * </p>
11	 *
12	 * <p>
13	 * The purpose of validation groups is to control which validation rules
14	 * are applied depending on the context, preventing unnecessary validations
15	 * for operations that don’t require them e.q. update requests
16	 * </p>
17	 */
18	public final class UserValidationGroups {
19	
20	    /**
21	     * Private constructor to prevent instantiation of this utility class.
22	     * Throws UnsupportedOperationException if called.
23	     */
24	    private UserValidationGroups() {
25	        throw new UnsupportedOperationException("Utility class - should not be instantiated");
26	    }
27	
28	    /**
29	     * Validation group for creating a new user.
30	     * <p>
31	     * This interface is used to mark the validation constraints that should
32	     * be applied when creating a new user (e.g., during user registration).
33	     * </p>
34	     */
35	    public interface Create {
36	    }
37	
38	    /**
39	     * Validation group for updating an existing user.
40	     * <p>
41	     * This interface is used to mark the validation constraints that should
42	     * be applied when updating a user.
43	     * </p>
44	     */
45	    public interface Update {
46	    }
47	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/entity/Address.java =====

1	package com.llmquality.baseline.entity;
2	
3	import com.llmquality.baseline.enums.AddressType;
4	import jakarta.persistence.*;
5	
6	import java.util.Objects;
7	
8	
9	@Entity
10	@Table(name = "addresses")
11	public class Address {
12	
13	    @Id
14	    @GeneratedValue(strategy = GenerationType.IDENTITY)
15	    private Long id;
16	
17	    @ManyToOne(fetch = FetchType.LAZY, optional = false)
18	    @JoinColumn(name = "user_id", nullable = false)
19	    private User user;
20	
21	    @Column(name = "street", nullable = false)
22	    private String street;
23	
24	    @Column(name = "house_number", nullable = false)
25	    private String houseNumber;
26	
27	    @Column(name = "postal_code", nullable = false)
28	    private String postalCode;
29	
30	    @Column(name = "city", nullable = false)
31	    private String city;
32	
33	    @Column(name = "country", nullable = false)
34	    private String country;
35	
36	    @Enumerated(EnumType.STRING)
37	    @Column(name = "address_type", nullable = false)
38	    private AddressType addressType;
39	
40	    public AddressType getAddressType() {
41	        return addressType;
42	    }
43	
44	    public void setAddressType(AddressType addressType) {
45	        this.addressType = addressType;
46	    }
47	
48	    public String getCountry() {
49	        return country;
50	    }
51	
52	    public void setCountry(String country) {
53	        this.country = country;
54	    }
55	
56	    public String getCity() {
57	        return city;
58	    }
59	
60	    public void setCity(String city) {
61	        this.city = city;
62	    }
63	
64	    public String getPostalCode() {
65	        return postalCode;
66	    }
67	
68	    public void setPostalCode(String postalCode) {
69	        this.postalCode = postalCode;
70	    }
71	
72	    public String getHouseNumber() {
73	        return houseNumber;
74	    }
75	
76	    public void setHouseNumber(String houseNumber) {
77	        this.houseNumber = houseNumber;
78	    }
79	
80	    public String getStreet() {
81	        return street;
82	    }
83	
84	    public void setStreet(String street) {
85	        this.street = street;
86	    }
87	
88	    public User getUser() {
89	        return user;
90	    }
91	
92	    public void setUser(User user) {
93	        this.user = user;
94	    }
95	
96	    public Long getId() {
97	        return id;
98	    }
99	
100	    public void setId(Long id) {
101	        this.id = id;
102	    }
103	
104	    @Override
105	    public boolean equals(Object o) {
106	        if (this == o) return true;
107	        if (!(o instanceof Address address)) return false;
108	        return Objects.equals(id, address.id);
109	    }
110	
111	    @Override
112	    public int hashCode() {
113	        return Objects.hash(id);
114	    }
115	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/entity/User.java =====

1	package com.llmquality.baseline.entity;
2	
3	import jakarta.persistence.*;
4	
5	import java.util.Objects;
6	
7	
8	@Entity
9	@Table(name = "users")
10	public class User {
11	
12	    @Id
13	    @GeneratedValue(strategy = GenerationType.IDENTITY)
14	    private Long id;
15	
16	    @Column(name = "username", nullable = false, unique = true)
17	    private String username;
18	
19	    @Column(name = "password", nullable = false, length = 60)
20	    private String password;
21	
22	    @Column(name = "email", nullable = false)
23	    private String email;
24	
25	    @Column(name = "isadmin", nullable = false)
26	    private boolean admin;
27	
28	    public boolean isAdmin() {
29	        return admin;
30	    }
31	
32	    public void setAdmin(boolean admin) {
33	        this.admin = admin;
34	    }
35	
36	    public String getEmail() {
37	        return email;
38	    }
39	
40	    public void setEmail(String email) {
41	        this.email = email;
42	    }
43	
44	    public String getPassword() {
45	        return password;
46	    }
47	
48	    public void setPassword(String password) {
49	        this.password = password;
50	    }
51	
52	    public String getUsername() {
53	        return username;
54	    }
55	
56	    public void setUsername(String username) {
57	        this.username = username;
58	    }
59	
60	    public Long getId() {
61	        return id;
62	    }
63	
64	    public void setId(Long id) {
65	        this.id = id;
66	    }
67	
68	    @Override
69	    public boolean equals(Object o) {
70	        if (this == o) return true;
71	        if (!(o instanceof User user)) return false;
72	        return Objects.equals(id, user.id);
73	    }
74	
75	    @Override
76	    public int hashCode() {
77	        return Objects.hash(id);
78	    }
79	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/enums/AddressType.java =====

1	package com.llmquality.baseline.enums;
2	
3	
4	/**
5	 * Enum representing the different types of addresses that a user can have.
6	 * <p>
7	 * This enum is used to categorize addresses into various types such as:
8	 * <ul>
9	 *     <li>{@link #PRIVATE} - A private address</li>
10	 *     <li>{@link #BUSINESS} - A business address</li>
11	 *     <li>{@link #SHIPPING} - A shipping address</li>
12	 *     <li>{@link #BILLING} - A billing address</li>
13	 * </ul>
14	 * </p>
15	 */
16	public enum AddressType {
17	    PRIVATE,
18	    BUSINESS,
19	    SHIPPING,
20	    BILLING
21	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/enums/Role.java =====

1	package com.llmquality.baseline.enums;
2	
3	
4	/**
5	 * Enum representing the roles available in the application.
6	 * Each role is associated with a string value used for
7	 * authorization and security purposes.
8	 *
9	 * <p>
10	 * Available roles:
11	 * <ul>
12	 *     <li>ADMIN - Represents an administrator with full access (ROLE_ADMIN)</li>
13	 *     <li>USER  - Represents a standard user with limited access (ROLE_USER)</li>
14	 * </ul>
15	 * </p>
16	 */
17	public enum Role {
18	    USER,
19	    ADMIN;
20	
21	    public static final String PREFIX = "ROLE_";
22	
23	    public String authority() {
24	        return PREFIX + name();
25	    }
26	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/BaselineProjectWebException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import java.io.Serial;
4	import java.io.Serializable;
5	
6	
7	/**
8	 * Abstract base class for custom exceptions used in the BaselineProject.
9	 * <p>
10	 * This class serves as the base for exceptions related to resource validation and error handling in the backend.
11	 * It holds information about the resource, field, and field value that caused the exception to be thrown.
12	 * Subclasses of this class should provide specific exception messages and behaviors.
13	 * </p>
14	 *
15	 * <p>Example:</p>
16	 * <pre>
17	 * throw new ResourceNotFoundException("not found", "User", "id", userId);
18	 * </pre>
19	 *
20	 * @see ResourceNotFoundException
21	 * @see ResourceAlreadyExistsException
22	 */
23	public abstract class BaselineProjectWebException extends RuntimeException {
24	
25	    @Serial
26	    private static final long serialVersionUID = -2713300573235999908L;
27	
28	    /**
29	     * Constructs a new BackendWebException with the specified message and details.
30	     * <p>
31	     * The message is formatted to include the resource name, message, field name, and field value.
32	     * </p>
33	     *
34	     * @param msg          the message to be included in the exception
35	     * @param resourceName the name of the resource
36	     * @param fieldName    the name of the field
37	     * @param fieldValue   the value of the field
38	     */
39	    protected BaselineProjectWebException(String msg, String resourceName, String fieldName, Serializable fieldValue) {
40	        super(String.format("%s %s %s : '%s'", resourceName, msg, fieldName, fieldValue));
41	    }
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/ResourceAlreadyExistsException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import org.springframework.http.HttpStatus;
4	import org.springframework.web.bind.annotation.ResponseStatus;
5	
6	import java.io.Serial;
7	import java.io.Serializable;
8	
9	
10	/**
11	 * Exception thrown when an attempt is made to create or modify a resource that already exists.
12	 * <p>
13	 * This exception is typically used when an attempt is made to create a resource (e.g., user, product) with
14	 * a unique field (e.g., email, username) that already exists in the system, violating the uniqueness constraint.
15	 * It returns a 409 Conflict HTTP status to indicate a conflict in the request due to existing data.
16	 * </p>
17	 *
18	 * <p>Example usage:</p>
19	 * <pre>
20	 * throw new ResourceAlreadyExistsException("User", "email", "test@example.com");
21	 * </pre>
22	 */
23	@ResponseStatus(value = HttpStatus.CONFLICT)
24	public class ResourceAlreadyExistsException extends BaselineProjectWebException {
25	
26	    @Serial
27	    private static final long serialVersionUID = 2978506968943653610L;
28	
29	    /**
30	     * Constructs a new ResourceAlreadyExistsException with a specified resource name, field name, and field value.
31	     * <p>
32	     * The exception message is formatted as "already exists" for the given resource and field.
33	     * </p>
34	     *
35	     * @param resourceName the name of the resource that the exception relates to (e.g., "User", "Product")
36	     * @param fieldName    the name of the field that caused the exception (e.g., "email", "username")
37	     * @param fieldValue   the value of the field that caused the exception (e.g., "test@example.com", "johndoe")
38	     */
39	    public ResourceAlreadyExistsException(String resourceName, String fieldName, Serializable fieldValue) {
40	        super("already exists", resourceName, fieldName, fieldValue);
41	    }
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/ResourceNotFoundException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import org.springframework.http.HttpStatus;
4	import org.springframework.web.bind.annotation.ResponseStatus;
5	
6	import java.io.Serial;
7	import java.io.Serializable;
8	
9	
10	/**
11	 * Exception thrown when a requested resource is not found in the system.
12	 * <p>
13	 * This exception is used to indicate that a resource, such as an entity or data, could not be found based on
14	 * the specified field and value. It returns a 404 Not Found HTTP status code to indicate that the requested
15	 * resource does not exist.
16	 * </p>
17	 *
18	 * <p>Example usage:</p>
19	 * <pre>
20	 * throw new ResourceNotFoundException("User", "id", 123);
21	 * </pre>
22	 */
23	@ResponseStatus(value = HttpStatus.NOT_FOUND)
24	public class ResourceNotFoundException extends BaselineProjectWebException {
25	
26	    @Serial
27	    private static final long serialVersionUID = 4703052950035630239L;
28	
29	    /**
30	     * Constructs a new ResourceNotFoundException with a specified resource name, field name, and field value.
31	     * <p>
32	     * The exception message is formatted as "not found with" for the given resource and field.
33	     * </p>
34	     *
35	     * @param resourceName the name of the resource that could not be found (e.g., "User", "Product")
36	     * @param fieldName    the name of the field that was used to search for the resource (e.g., "id", "username")
37	     * @param fieldValue   the value of the field that was used to search for the resource (e.g., 123, "john_doe")
38	     */
39	    public ResourceNotFoundException(String resourceName, String fieldName, Serializable fieldValue) {
40	        super("not found with", resourceName, fieldName, fieldValue);
41	    }
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/UnauthorizedException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import org.springframework.http.HttpStatus;
4	import org.springframework.web.bind.annotation.ResponseStatus;
5	
6	import java.io.Serial;
7	import java.io.Serializable;
8	
9	
10	/**
11	 * Thrown when authentication fails due to invalid username or password.
12	 * <p>
13	 * This exception is annotated with {@code @ResponseStatus(HttpStatus.UNAUTHORIZED)} and therefore
14	 * automatically returns HTTP 401 Unauthorized without any additional configuration.
15	 * </p>
16	 * <p>
17	 * It is the recommended way in modern Spring Boot 3+ REST APIs to handle failed login attempts.
18	 * Using this instead of returning {@code success: false} with 200 OK prevents information leakage
19	 * (username enumeration) and follows proper HTTP semantics.
20	 * </p>
21	 * <p>
22	 * Example usage:
23	 * <pre>
24	 * throw new UnauthorizedException("User", "username", username);
25	 * </pre>
26	 * </p>
27	 */
28	@ResponseStatus(value = HttpStatus.UNAUTHORIZED)
29	public class UnauthorizedException extends BaselineProjectWebException {
30	
31	    @Serial
32	    private static final long serialVersionUID = -4368911695070591266L;
33	
34	    /**
35	     * Constructs a new UnauthorizedException with details about the authentication failure.
36	     * <p>
37	     * The exception message is formatted as "access unauthorized for {resourceName} {fieldName} : '{fieldValue}'".
38	     * </p>
39	     *
40	     * @param resourceName the name of the resource that required authentication (e.g., "User")
41	     * @param fieldName    the name of the field that caused the failure (e.g., "username" or "credentials")
42	     * @param fieldValue   the value of the field that was invalid (e.g., the provided username)
43	     */
44	    public UnauthorizedException(String resourceName, String fieldName, Serializable fieldValue) {
45	        super("access unauthorized for", resourceName, fieldName, fieldValue);
46	    }
47	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/handler/GlobalExceptionHandler.java =====

1	package com.llmquality.baseline.exception.handler;
2	
3	import com.llmquality.baseline.exception.BaselineProjectWebException;
4	import org.springframework.http.HttpStatus;
5	import org.springframework.http.ResponseEntity;
6	import org.springframework.http.converter.HttpMessageNotReadableException;
7	import org.springframework.web.bind.MethodArgumentNotValidException;
8	import org.springframework.web.bind.annotation.ExceptionHandler;
9	import org.springframework.web.bind.annotation.ResponseStatus;
10	import org.springframework.web.bind.annotation.RestControllerAdvice;
11	
12	import java.util.List;
13	
14	
15	/**
16	 * Global exception handler that converts domain-specific and validation-related
17	 * exceptions into clean and consistent API error responses.
18	 */
19	@RestControllerAdvice
20	public class GlobalExceptionHandler {
21	
22	    @ExceptionHandler(BaselineProjectWebException.class)
23	    public ResponseEntity<ErrorResponse> handleBaselineException(final BaselineProjectWebException ex) {
24	        final ResponseStatus annotation = ex.getClass().getAnnotation(ResponseStatus.class);
25	        final HttpStatus httpStatus = (annotation != null) ? annotation.value() : HttpStatus.INTERNAL_SERVER_ERROR;
26	        return ResponseEntity.status(httpStatus)
27	                .body(new ErrorResponse(
28	                        httpStatus.value(),
29	                        ex.getMessage()
30	                ));
31	    }
32	
33	    @ExceptionHandler(MethodArgumentNotValidException.class)
34	    public ResponseEntity<ValidationErrorResponse> handleValidation(final MethodArgumentNotValidException ex) {
35	        final List<ValidationErrorResponse.FieldError> errors =
36	                ex.getBindingResult().getFieldErrors()
37	                        .stream()
38	                        .map(err -> new ValidationErrorResponse.FieldError(
39	                                err.getField(),
40	                                err.getRejectedValue(),
41	                                err.getDefaultMessage()
42	                        ))
43	                        .toList();
44	        return ResponseEntity.badRequest().body(new ValidationErrorResponse(400, "Validation failed", errors));
45	    }
46	
47	    @ExceptionHandler(HttpMessageNotReadableException.class)
48	    public ResponseEntity<ErrorResponse> handleMalformedJson(final HttpMessageNotReadableException ex) {
49	        return ResponseEntity.badRequest().body(new ErrorResponse(HttpStatus.BAD_REQUEST.value(),
50	                "Malformed JSON request: " + ex.getMostSpecificCause().getMessage()));
51	    }
52	
53	
54	    // Response Records
55	    public record ErrorResponse(int status, String message) {
56	    }
57	
58	    public record ValidationErrorResponse(int status, String message, List<FieldError> errors) {
59	        public record FieldError(String field, Object rejectedValue, String message) {
60	        }
61	    }
62	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/logging/LoggingConfig.java =====

1	package com.llmquality.baseline.logging;
2	
3	import ch.qos.logback.classic.AsyncAppender;
4	import ch.qos.logback.classic.Level;
5	import ch.qos.logback.classic.Logger;
6	import ch.qos.logback.classic.LoggerContext;
7	import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
8	import ch.qos.logback.classic.spi.ILoggingEvent;
9	import ch.qos.logback.core.ConsoleAppender;
10	import ch.qos.logback.core.rolling.RollingFileAppender;
11	import ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy;
12	import ch.qos.logback.core.util.FileSize;
13	import jakarta.annotation.PostConstruct;
14	import jakarta.annotation.PreDestroy;
15	import org.slf4j.LoggerFactory;
16	import org.springframework.beans.factory.annotation.Value;
17	import org.springframework.context.annotation.Configuration;
18	import org.springframework.core.env.Environment;
19	
20	import java.nio.file.Files;
21	import java.nio.file.Path;
22	import java.nio.file.Paths;
23	import java.util.Map;
24	import java.util.Objects;
25	
26	
27	/**
28	 * Configures programmatic Logback logging for the application.
29	 * <p>
30	 * Features:
31	 * <ul>
32	 *     <li>Profile-aware log levels (dev = DEBUG, others = INFO by default)</li>
33	 *     <li>Asynchronous file logging with size/time-based rolling</li>
34	 * <li>Optional synchronous console logging</li>
35	 *     <li>Fully configurable via Spring Boot properties</li>
36	 * </ul>
37	 * This replaces XML configuration and initializes Logback at startup.
38	 */
39	@Configuration
40	public class LoggingConfig {
41	
42	    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(LoggingConfig.class);
43	
44	    private static final String DEFAULT_LOG_DIR = "logs";
45	    private static final String DEFAULT_LOG_FILE = "application.log";
46	    private static final String DEFAULT_LOG_PATTERN = "%d{yyyy-MM-dd HH:mm:ss,UTC} [%thread] %-5level %logger{36} - %msg%n";
47	    private static final String DEFAULT_ROLLING_PATTERN = "application-%d{yyyy-MM-dd}.%i.log";
48	    private static final String DEFAULT_MAX_FILE_SIZE = "10MB";
49	    private static final String DEFAULT_TOTAL_SIZE_CAP = "100MB";
50	
51	    @Value("${logging.file.path:${user.dir}/logs}")
52	    private String logDirectoryPath;
53	
54	    @Value("${logging.file.name:" + DEFAULT_LOG_FILE + "}")
55	    private String logFileName;
56	
57	    @Value("${logging.level.root:#{null}}")
58	    private String rootLogLevel;
59	
60	    @Value("#{${logging.level:{:}}}")
61	    private Map<String, String> loggerLevels;
62	
63	    @Value("${logging.console.enabled:#{null}}")
64	    private Boolean consoleEnabled;
65	
66	    @Value("${logging.pattern:" + DEFAULT_LOG_PATTERN + "}")
67	    private String logPattern;
68	
69	    @Value("${logging.rolling.fileNamePattern:" + DEFAULT_ROLLING_PATTERN + "}")
70	    private String rollingFileNamePattern;
71	
72	    @Value("${logging.rolling.maxFileSize:10MB}")
73	    private String maxFileSizeStr;
74	
75	    @Value("${logging.rolling.maxHistory:30}")
76	    private int maxHistory;
77	
78	    @Value("${logging.rolling.totalSizeCap:100MB}")
79	    private String totalSizeCapStr;
80	
81	    private final Environment environment;
82	    private LoggerContext loggerContext;
83	    private volatile boolean initialized = false;
84	
85	    public LoggingConfig(Environment environment) {
86	        this.environment = environment;
87	    }
88	
89	    @PostConstruct
90	    public synchronized void initializeLogging() {
91	        if (initialized) return;
92	        initialized = true;
93	
94	        try {
95	            loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
96	
97	            Path logDir = createLogDirectory(logDirectoryPath);
98	
99	            String[] activeProfiles = environment.getActiveProfiles();
100	            String profile = activeProfiles.length > 0 ? activeProfiles[0] : "dev";
101	
102	            Level level;
103	            boolean console;
104	            if (rootLogLevel != null) {
105	                level = Level.toLevel(rootLogLevel, Level.INFO);
106	            } else if ("dev".equals(profile)) {
107	                level = Level.DEBUG;
108	            } else {
109	                level = Level.INFO;
110	            }
111	
112	            console = Objects.requireNonNullElseGet(consoleEnabled, () -> "dev".equals(profile));
113	
114	            RollingFileAppender<ILoggingEvent> rollingFileAppender = createRollingFileAppender(logDir);
115	
116	            AsyncAppender asyncFileAppender = new AsyncAppender();
117	            asyncFileAppender.setContext(loggerContext);
118	            asyncFileAppender.setName("ASYNC_FILE");
119	            asyncFileAppender.addAppender(rollingFileAppender);
120	            asyncFileAppender.start();
121	
122	            ConsoleAppender<ILoggingEvent> consoleAppender = null;
123	            if (console) {
124	                consoleAppender = createConsoleAppender();
125	            }
126	
127	            configureRootLogger(asyncFileAppender, consoleAppender, level);
128	
129	            configurePackageSpecificLoggers();
130	
131	            LOG.info("Logging initialized successfully. Profile: {}. Log directory: {}", profile, logDir.toAbsolutePath());
132	
133	        } catch (Exception e) {
134	            LOG.error("Failed to initialize logging", e);
135	        }
136	    }
137	
138	    @PreDestroy
139	    public void shutdownLogging() {
140	        if (loggerContext != null) {
141	            loggerContext.stop();
142	        }
143	    }
144	
145	    private Path createLogDirectory(String path) {
146	        Objects.requireNonNull(path, "Log directory path must not be null");
147	        try {
148	            Path logPath = Paths.get(path);
149	            if (!Files.exists(logPath)) Files.createDirectories(logPath);
150	            return logPath;
151	        } catch (Exception e) {
152	            LOG.error("Failed to create log directory '{}'. Falling back to '{}'.", path, DEFAULT_LOG_DIR, e);
153	            try {
154	                Path fallback = Paths.get(DEFAULT_LOG_DIR);
155	                Files.createDirectories(fallback);
156	                return fallback;
157	            } catch (Exception ex) {
158	                LOG.error("Fallback directory '{}' failed. Using current dir.", DEFAULT_LOG_DIR, ex);
159	                return Paths.get(".");
160	            }
161	        }
162	    }
163	
164	    private PatternLayoutEncoder createEncoder(String pattern) {
165	        if (pattern == null || pattern.isEmpty()) {
166	            pattern = DEFAULT_LOG_PATTERN;
167	        }
168	        PatternLayoutEncoder encoder = new PatternLayoutEncoder();
169	        encoder.setContext(loggerContext);
170	        encoder.setPattern(pattern);
171	        encoder.start();
172	        return encoder;
173	    }
174	
175	    private RollingFileAppender<ILoggingEvent> createRollingFileAppender(Path logDir) {
176	        PatternLayoutEncoder encoder = createEncoder(logPattern);
177	
178	        RollingFileAppender<ILoggingEvent> rollingFileAppender = new RollingFileAppender<>();
179	        rollingFileAppender.setContext(loggerContext);
180	        rollingFileAppender.setName("ROLLING_FILE");
181	        rollingFileAppender.setFile(logDir.resolve(logFileName).toString());
182	        rollingFileAppender.setEncoder(encoder);
183	
184	        SizeAndTimeBasedRollingPolicy<ILoggingEvent> rollingPolicy = new SizeAndTimeBasedRollingPolicy<>();
185	        rollingPolicy.setContext(loggerContext);
186	        rollingPolicy.setParent(rollingFileAppender);
187	
188	        if (rollingFileNamePattern == null || rollingFileNamePattern.isEmpty()) {
189	            rollingFileNamePattern = DEFAULT_ROLLING_PATTERN;
190	        }
191	        rollingPolicy.setFileNamePattern(logDir.resolve(rollingFileNamePattern).toString());
192	
193	        FileSize maxFileSize;
194	        try {
195	            maxFileSize = FileSize.valueOf(maxFileSizeStr);
196	        } catch (Exception e) {
197	            LOG.warn("Invalid maxFileSize '{}', using default {}", maxFileSizeStr, DEFAULT_MAX_FILE_SIZE);
198	            maxFileSize = FileSize.valueOf(DEFAULT_MAX_FILE_SIZE);
199	        }
200	        rollingPolicy.setMaxFileSize(maxFileSize);
201	
202	        rollingPolicy.setMaxHistory(maxHistory);
203	
204	        FileSize totalSizeCap;
205	        try {
206	            totalSizeCap = FileSize.valueOf(totalSizeCapStr);
207	        } catch (Exception e) {
208	            LOG.warn("Invalid totalSizeCap '{}', using default {}", totalSizeCapStr, DEFAULT_TOTAL_SIZE_CAP);
209	            totalSizeCap = FileSize.valueOf(DEFAULT_TOTAL_SIZE_CAP);
210	        }
211	        rollingPolicy.setTotalSizeCap(totalSizeCap);
212	
213	        rollingPolicy.start();
214	        rollingFileAppender.setRollingPolicy(rollingPolicy);
215	        rollingFileAppender.start();
216	
217	        return rollingFileAppender;
218	    }
219	
220	
221	    private ConsoleAppender<ILoggingEvent> createConsoleAppender() {
222	        PatternLayoutEncoder encoder = createEncoder(logPattern);
223	        ConsoleAppender<ILoggingEvent> consoleAppender = new ConsoleAppender<>();
224	        consoleAppender.setContext(loggerContext);
225	        consoleAppender.setName("CONSOLE");
226	        consoleAppender.setEncoder(encoder);
227	        consoleAppender.start();
228	        return consoleAppender;
229	    }
230	
231	    private void configureRootLogger(AsyncAppender asyncFileAppender,
232	                                     ConsoleAppender<ILoggingEvent> consoleAppender,
233	                                     Level level) {
234	
235	        Logger rootLogger = loggerContext.getLogger("com.llmquality.baseline");
236	        rootLogger.detachAndStopAllAppenders();
237	
238	        rootLogger.addAppender(asyncFileAppender);
239	
240	        if (consoleAppender != null) {
241	            rootLogger.addAppender(consoleAppender);
242	        }
243	
244	        rootLogger.setLevel(level);
245	        rootLogger.setAdditive(false);
246	    }
247	
248	    private void configurePackageSpecificLoggers() {
249	        for (Map.Entry<String, String> entry : loggerLevels.entrySet()) {
250	            String loggerName = entry.getKey();
251	            if ("root".equalsIgnoreCase(loggerName)) {
252	                continue; // Root is already configured
253	            }
254	            Level lvl = Level.toLevel(entry.getValue(), Level.INFO);
255	            loggerContext.getLogger(loggerName).setLevel(lvl);
256	        }
257	    }
258	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/mapper/AddressMapper.java =====

1	package com.llmquality.baseline.mapper;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.entity.Address;
6	import com.llmquality.baseline.entity.User;
7	import org.mapstruct.*;
8	
9	
10	/**
11	 * Mapper interface for converting between {@link Address} entity and Address DTOs.
12	 * <p>
13	 * This interface defines the mappings to transform the {@link AddressRequest} to an {@link Address} entity,
14	 * and vice versa, as well as handling address updates from {@link AddressRequest}.
15	 * </p>
16	 */
17	@Mapper(componentModel = "spring")
18	public interface AddressMapper {
19	
20	    /**
21	     * Maps an {@link AddressRequest} DTO and a {@link User} entity to an {@link Address} entity.
22	     * The {@code id} field is ignored because it is managed by the database.
23	     * The user is mapped as a reference in the entity.
24	     *
25	     * @param addressRequest the {@link AddressRequest} DTO to map
26	     * @param user           the {@link User} entity that the address is associated with
27	     * @return the mapped {@link Address} entity
28	     */
29	    @Mapping(target = "id", ignore = true)
30	    @Mapping(target = "user", source = "user")
31	    Address toAddressEntity(AddressRequest addressRequest, User user);
32	
33	    /**
34	     * Maps an {@link Address} entity to an {@link AddressResponse} DTO.
35	     * The user's ID is mapped from the {@link User} entity to the {@link AddressResponse}.
36	     *
37	     * @param address the {@link Address} entity to map
38	     * @return the mapped {@link AddressResponse} DTO
39	     */
40	    @Mapping(target = "userId", source = "user.id")
41	    AddressResponse toAddressResponse(Address address);
42	
43	    /**
44	     * Updates an {@link Address} entity using values from the provided {@link AddressRequest} DTO.
45	     * <p>
46	     * The {@code id} and {@code user} fields are ignored since they should not be modified.
47	     * Only non-null values from the DTO will be mapped onto the existing entity.
48	     * </p>
49	     *
50	     * @param addressRequest the {@link AddressRequest} DTO containing the updated data
51	     * @param address        the {@link Address} entity to update
52	     * @return the updated {@link Address} entity
53	     */
54	    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
55	    @Mapping(target = "id", ignore = true)
56	    @Mapping(target = "user", ignore = true)
57	    Address updateAddressEntityFromAddressRequest(AddressRequest addressRequest, @MappingTarget Address address);
58	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/mapper/UserMapper.java =====

1	package com.llmquality.baseline.mapper;
2	
3	import com.llmquality.baseline.dto.UserRequest;
4	import com.llmquality.baseline.dto.UserResponse;
5	import com.llmquality.baseline.entity.User;
6	import org.mapstruct.*;
7	import org.springframework.security.crypto.password.PasswordEncoder;
8	
9	
10	/**
11	 * Mapper interface for converting between database entity {@link User} and User DTOs.
12	 */
13	@Mapper(componentModel = "spring")
14	public interface UserMapper {
15	
16	    /**
17	     * Maps a {@link UserRequest} to a {@link User} entity.
18	     * The {@code id} is ignored since it is managed by JPA/database.
19	     * The password is hashed using the provided {@link PasswordEncoder}.
20	     *
21	     * @param dto             the DTO to map
22	     * @param passwordEncoder the password encoder to hash the password
23	     * @return the mapped User entity with hashed password
24	     */
25	    @Mapping(target = "id", ignore = true)
26	    @Mapping(target = "password", expression = "java(passwordEncoder.encode(dto.password()))")
27	    User toUserEntity(UserRequest dto, @Context PasswordEncoder passwordEncoder);
28	
29	    /**
30	     * Maps a {@link User} entity to a {@link UserResponse}.
31	     *
32	     * @param user the entity to map
33	     * @return the DTO representing the user without sensitive data
34	     */
35	    UserResponse toUserResponse(User user);
36	
37	    /**
38	     * Updates the fields of the given {@link User} entity using values from the provided {@link UserRequest} DTO.
39	     * <p>
40	     * The method will map the following fields:
41	     * <ul>
42	     *     <li> {@code id} is ignored (not mapped) </li>
43	     *     <li> {@code username}, {@code email}, {@code password}, and {@code admin} are mapped from the DTO to the entity,
44	     *          with any {@code null} values being ignored. </li>
45	     * </ul>
46	     * The password is hashed using the provided {@link PasswordEncoder}.
47	     *
48	     * @param dto             the {@link UserRequest} DTO containing the data to update the entity.
49	     * @param entity          the {@link User} entity to be updated.
50	     * @param passwordEncoder the password encoder to hash the password
51	     * @return the mapped User entity with hashed password(if changed)
52	     */
53	    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
54	    @Mapping(target = "id", ignore = true)
55	    @Mapping(target = "password",
56	            expression = "java(dto.password() != null ? passwordEncoder.encode(dto.password()) : entity.getPassword())")
57	    User updateUserEntityFromUserRequest(UserRequest dto, @MappingTarget User entity, @Context PasswordEncoder passwordEncoder);
58	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/repository/AddressRepository.java =====

1	package com.llmquality.baseline.repository;
2	
3	import com.llmquality.baseline.entity.Address;
4	import org.springframework.data.domain.Page;
5	import org.springframework.data.domain.Pageable;
6	import org.springframework.data.jpa.repository.JpaRepository;
7	import org.springframework.stereotype.Repository;
8	
9	
10	@Repository
11	public interface AddressRepository extends JpaRepository<Address, Long> {
12	
13	    Page<Address> findAllByUserId(Long userId, Pageable pageable);
14	
15	    boolean existsByIdAndUserId(Long id, Long userId);
16	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/repository/UserRepository.java =====

1	package com.llmquality.baseline.repository;
2	
3	import com.llmquality.baseline.entity.User;
4	import org.springframework.data.jpa.repository.JpaRepository;
5	import org.springframework.stereotype.Repository;
6	
7	import java.util.Optional;
8	
9	
10	@Repository
11	public interface UserRepository extends JpaRepository<User, Long> {
12	
13	    Optional<User> findByUsername(String username);
14	
15	    boolean existsByUsername(String username);
16	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/security/SecurityConfig.java =====

1	package com.llmquality.baseline.security;
2	
3	import com.nimbusds.jose.jwk.source.ImmutableSecret;
4	import org.springframework.beans.factory.annotation.Value;
5	import org.springframework.context.annotation.Bean;
6	import org.springframework.context.annotation.Configuration;
7	import org.springframework.http.HttpMethod;
8	import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
9	import org.springframework.security.config.annotation.web.builders.HttpSecurity;
10	import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
11	import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
12	import org.springframework.security.config.http.SessionCreationPolicy;
13	import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
14	import org.springframework.security.crypto.password.PasswordEncoder;
15	import org.springframework.security.oauth2.jwt.JwtDecoder;
16	import org.springframework.security.oauth2.jwt.JwtEncoder;
17	import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
18	import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
19	import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
20	import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
21	import org.springframework.security.web.SecurityFilterChain;
22	
23	import javax.crypto.SecretKey;
24	import javax.crypto.spec.SecretKeySpec;
25	import java.util.Base64;
26	
27	
28	/**
29	 * Configuration class for application security.
30	 * <p>
31	 * This class sets up the security filter chain, password encoding, and JWT encoding/decoding
32	 * for the application using Spring Security. It configures stateless session management,
33	 * disables CSRF protection for simplicity in a REST API context, and sets access rules
34	 * for public and authenticated endpoints.
35	 * </p>
36	 * <p>
37	 * The JWT secret key is injected from application properties and used for both encoding
38	 * and decoding JWT tokens. A {@link PasswordEncoder} bean is also provided for hashing
39	 * user passwords securely.
40	 * </p>
41	 * <p>
42	 * Public endpoints include login and user registration, while all other requests require
43	 * authentication. OAuth2 resource server support is enabled for JWT-based authentication.
44	 * </p>
45	 */
46	@Configuration
47	@EnableWebSecurity
48	@EnableMethodSecurity
49	public class SecurityConfig {
50	
51	    @Value("${jwt.secret}")
52	    private String jwtSecret;
53	
54	    @Value("${api.base-path}")
55	    private String apiBasePath;
56	
57	    private static final String JWT_ALGORITHM = "HmacSHA256";
58	
59	    private static final int MIN_SECRET_BYTES = 32;
60	
61	    @Bean
62	    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
63	        http
64	                .csrf(AbstractHttpConfigurer::disable)
65	                .authorizeHttpRequests(auth -> auth
66	                        .requestMatchers("/error", "/error/**").permitAll()
67	                        .requestMatchers(apiBasePath + "/users/login").permitAll()
68	                        .requestMatchers(HttpMethod.POST, apiBasePath + "/users").permitAll()
69	                        .anyRequest().authenticated()
70	                )
71	                .oauth2ResourceServer(oauth2 -> oauth2
72	                        .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter())
73	                        )
74	                )
75	                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
76	
77	        return http.build();
78	    }
79	
80	    @Bean
81	    public JwtAuthenticationConverter jwtAuthenticationConverter() {
82	        JwtGrantedAuthoritiesConverter authoritiesConverter = new JwtGrantedAuthoritiesConverter();
83	        authoritiesConverter.setAuthorityPrefix("ROLE_");
84	        authoritiesConverter.setAuthoritiesClaimName("scope");
85	
86	        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
87	        converter.setJwtGrantedAuthoritiesConverter(authoritiesConverter);
88	        converter.setPrincipalClaimName("sub");
89	        return converter;
90	    }
91	
92	    @Bean
93	    public PasswordEncoder passwordEncoder() {
94	        return new BCryptPasswordEncoder();
95	    }
96	
97	    @Bean
98	    public JwtEncoder jwtEncoder() {
99	        SecretKey key = createSecretKey(jwtSecret);
100	        return new NimbusJwtEncoder(new ImmutableSecret<>(key));
101	    }
102	
103	    @Bean
104	    public JwtDecoder jwtDecoder() {
105	        SecretKey key = createSecretKey(jwtSecret);
106	        return NimbusJwtDecoder.withSecretKey(key).build();
107	    }
108	
109	    private SecretKey createSecretKey(String base64Secret) {
110	        if (base64Secret == null || base64Secret.isBlank()) {
111	            throw new IllegalStateException("JWT secret is not configured. Please set 'jwt.secret' in your application properties.");
112	        }
113	        byte[] secretBytes;
114	        try {
115	            secretBytes = Base64.getDecoder().decode(base64Secret);
116	        } catch (IllegalArgumentException ex) {
117	            throw new IllegalStateException("JWT secret is not valid Base64: " + base64Secret, ex);
118	        }
119	        if (secretBytes.length < MIN_SECRET_BYTES) {
120	            throw new IllegalStateException("JWT secret too short; must be at least 32 bytes (after Base64 decoding).");
121	        }
122	        return new SecretKeySpec(secretBytes, JWT_ALGORITHM);
123	    }
124	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/security/SecurityExpressions.java =====

1	package com.llmquality.baseline.security;
2	
3	import com.llmquality.baseline.enums.Role;
4	import org.springframework.security.core.Authentication;
5	import org.springframework.stereotype.Component;
6	
7	
8	/**
9	 * Custom Spring Security expressions for method security.
10	 * <p>
11	 * Registered as Spring bean with name "sec" → usable in @PreAuthorize as @sec.xxx()
12	 * This is the official and recommended way to keep @PreAuthorize expressions clean and testable.
13	 * </p>
14	 */
15	@Component("sec")
16	public class SecurityExpressions {
17	
18	    public boolean isOwner(Long resourceOwnerId, Authentication auth) {
19	        return resourceOwnerId != null
20	                && auth != null
21	                && auth.getName() != null
22	                && resourceOwnerId.toString().equals(auth.getName());
23	    }
24	
25	    public boolean canSetAdminFlag(Boolean newValue, Authentication auth) {
26	        return newValue == null || !newValue || isAdmin(auth);
27	    }
28	
29	    public boolean isAdmin(Authentication auth) {
30	        if (auth == null || auth.getAuthorities() == null) return false;
31	        return auth.getAuthorities().stream()
32	                .anyMatch(granted -> Role.ADMIN.authority().equals(granted.getAuthority()));
33	    }
34	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/AddressServiceImpl.java =====

1	package com.llmquality.baseline.service;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.dto.PagedResponse;
6	import com.llmquality.baseline.entity.Address;
7	import com.llmquality.baseline.entity.User;
8	import com.llmquality.baseline.exception.ResourceNotFoundException;
9	import com.llmquality.baseline.mapper.AddressMapper;
10	import com.llmquality.baseline.repository.AddressRepository;
11	import com.llmquality.baseline.repository.UserRepository;
12	import com.llmquality.baseline.service.interfaces.AddressService;
13	import org.slf4j.LoggerFactory;
14	import org.springframework.data.domain.Page;
15	import org.springframework.data.domain.Pageable;
16	import org.springframework.stereotype.Service;
17	import org.springframework.transaction.annotation.Transactional;
18	
19	import java.util.Objects;
20	
21	
22	@Service
23	@Transactional(readOnly = true)
24	public class AddressServiceImpl implements AddressService {
25	
26	    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(AddressServiceImpl.class);
27	
28	    private static final String USER = "User";
29	
30	    private static final String ADDRESS = "Address";
31	
32	    private final AddressRepository addressRepository;
33	
34	    private final UserRepository userRepository;
35	
36	    private final AddressMapper addressMapper;
37	
38	
39	    public AddressServiceImpl(AddressRepository addressRepository, UserRepository userRepository, AddressMapper addressMapper) {
40	        this.addressRepository = addressRepository;
41	        this.userRepository = userRepository;
42	        this.addressMapper = addressMapper;
43	    }
44	
45	    @Override
46	    public PagedResponse<AddressResponse> listAll(final Long userId, final Pageable pageable) {
47	        LOG.debug("--> listAll, page={}, size={}", pageable.getPageNumber(), pageable.getPageSize());
48	
49	        final User existingUserEntity = userRepository.findById(userId)
50	                .orElseThrow(() -> {
51	                    LOG.error("<-- listAll, User with ID {} not found", userId);
52	                    return new ResourceNotFoundException(USER, "id", userId);
53	                });
54	
55	        final Page<AddressResponse> page = addressRepository
56	                .findAllByUserId(existingUserEntity.getId(), pageable)
57	                .map(addressMapper::toAddressResponse);
58	        LOG.debug("<-- listAll, total elements={}, total pages={}", page.getTotalElements(), page.getTotalPages());
59	        return PagedResponse.fromPage(page);
60	    }
61	
62	    @Override
63	    public AddressResponse getById(Long userId, Long addressId) {
64	        LOG.debug("--> getById, userId: {} and addressId: {}", userId, addressId);
65	        final Address existingAddressEntity = addressRepository.findById(addressId)
66	                .orElseThrow(() -> {
67	                    LOG.error("<-- getById, Address with ID {} not found", addressId);
68	                    return new ResourceNotFoundException(ADDRESS, "id", addressId);
69	                });
70	
71	        enforceAddressOwnership(existingAddressEntity, userId);
72	
73	        final AddressResponse addressResponse = addressMapper.toAddressResponse(existingAddressEntity);
74	        LOG.debug("<-- getById, userId: {} and addressId: {}", userId, addressResponse.id());
75	        return addressResponse;
76	    }
77	
78	    @Transactional
79	    @Override
80	    public AddressResponse save(final Long userId, final AddressRequest addressRequest) {
81	        LOG.debug("--> save, address for user with userId: {}", userId);
82	        final User existingUserEntity = userRepository.findById(userId)
83	                .orElseThrow(() -> {
84	                    LOG.error("<-- getById, User with userId {} not found", userId);
85	                    return new ResourceNotFoundException(USER, "id", userId);
86	                });
87	
88	        final Address addressEntity = addressMapper.toAddressEntity(addressRequest, existingUserEntity);
89	        final AddressResponse addressResponse = addressMapper.toAddressResponse(addressRepository.save(addressEntity));
90	        LOG.debug("<-- save, address saved with id: {}", addressEntity.getId());
91	        return addressResponse;
92	    }
93	
94	    @Transactional
95	    @Override
96	    public AddressResponse update(final Long userId, final Long addressId, final AddressRequest addressRequest) {
97	        LOG.debug("--> update, address with addressId: {} by userId: {}", addressId, userId);
98	        final Address existingAddressEntity = addressRepository.findById(addressId)
99	                .orElseThrow(() -> {
100	                    LOG.error("<-- update, Address with ID {} not found", addressId);
101	                    return new ResourceNotFoundException(ADDRESS, "id", addressId);
102	                });
103	
104	        enforceAddressOwnership(existingAddressEntity, userId);
105	
106	        // Partial update via updateAddressEntityFromAddressRequest
107	        final Address updatedAddressEntity = addressMapper.updateAddressEntityFromAddressRequest(addressRequest, existingAddressEntity);
108	        final Address saveAddressEntity = addressRepository.save(updatedAddressEntity);
109	        final AddressResponse addressResponse = addressMapper.toAddressResponse(saveAddressEntity);
110	        LOG.debug("<-- update, address with addressId: {} by userId: {}", addressResponse.id(), addressResponse.userId());
111	        return addressResponse;
112	    }
113	
114	    @Transactional
115	    @Override
116	    public void delete(final Long userId, final Long addressId) {
117	        LOG.debug("--> delete, addressId: {}", addressId);
118	        final Address existingAddressEntity = addressRepository.findById(addressId)
119	                .orElseThrow(() -> {
120	                    LOG.error("<-- delete, Address with ID {} not found", addressId);
121	                    return new ResourceNotFoundException(ADDRESS, "id", addressId);
122	                });
123	
124	        enforceAddressOwnership(existingAddressEntity, userId);
125	
126	        addressRepository.delete(existingAddressEntity);
127	        LOG.debug("<-- delete, address with id {} deleted", existingAddressEntity.getId());
128	    }
129	
130	    /**
131	     * Enforces that the given address belongs to the requested user.
132	     * <p>
133	     * Throws {@link ResourceNotFoundException} (404) on mismatch to prevent information disclosure.
134	     * Must be called after loading the address and after coarse-grained {@code @PreAuthorize} check.
135	     * </p>
136	     *
137	     * @param address         the loaded address entity
138	     * @param requestedUserId the userId from the request path
139	     * @throws ResourceNotFoundException if address does not belong to requestedUserId
140	     */
141	    private void enforceAddressOwnership(Address address, Long requestedUserId) {
142	        LOG.debug("--> enforceAddressOwnership");
143	        final Long ownerId = (address.getUser() != null) ? address.getUser().getId() : null;
144	
145	        if (!Objects.equals(ownerId, requestedUserId)) {
146	            LOG.warn("<-- enforceAddressOwnership, Access denied: User {} tried to access address {} (ownerId={})",
147	                    requestedUserId, address.getId(), ownerId);
148	            throw new ResourceNotFoundException(ADDRESS, "id", address.getId());
149	        }
150	        LOG.debug("<-- enforceAddressOwnership, Ownership confirmed");
151	    }
152	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/UserServiceImpl.java =====

1	package com.llmquality.baseline.service;
2	
3	import com.llmquality.baseline.dto.*;
4	import com.llmquality.baseline.entity.User;
5	import com.llmquality.baseline.enums.Role;
6	import com.llmquality.baseline.exception.ResourceAlreadyExistsException;
7	import com.llmquality.baseline.exception.ResourceNotFoundException;
8	import com.llmquality.baseline.exception.UnauthorizedException;
9	import com.llmquality.baseline.mapper.UserMapper;
10	import com.llmquality.baseline.repository.UserRepository;
11	import com.llmquality.baseline.service.interfaces.UserService;
12	import org.slf4j.LoggerFactory;
13	import org.springframework.beans.factory.annotation.Autowired;
14	import org.springframework.beans.factory.annotation.Value;
15	import org.springframework.data.domain.Page;
16	import org.springframework.data.domain.Pageable;
17	import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
18	import org.springframework.security.oauth2.jwt.JwsHeader;
19	import org.springframework.security.oauth2.jwt.JwtClaimsSet;
20	import org.springframework.security.oauth2.jwt.JwtEncoder;
21	import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
22	import org.springframework.stereotype.Service;
23	import org.springframework.security.crypto.password.PasswordEncoder;
24	import org.springframework.transaction.annotation.Transactional;
25	
26	import java.time.Duration;
27	import java.time.Instant;
28	import java.time.temporal.ChronoUnit;
29	import java.util.Objects;
30	
31	
32	@Service
33	@Transactional(readOnly = true)
34	public class UserServiceImpl implements UserService {
35	
36	    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(UserServiceImpl.class);
37	
38	    private static final String USER = "User";
39	
40	    // Prevent timing attack (username enumeration) by always performing password comparison
41	    private static final String DUMMY_HASH = "$2a$10$dummydummydummydummydummydummydummydummydummydummy";
42	
43	    private final UserRepository userRepository;
44	
45	    private final PasswordEncoder passwordEncoder;
46	
47	    private final UserMapper userMapper;
48	
49	    private final JwtEncoder jwtEncoder;
50	
51	    @Value("${jwt.issuer:self}")
52	    private String jwtIssuer;
53	
54	    @Value("${jwt.expiration-hours:6}")
55	    private long jwtExpirationHours;
56	
57	    @Autowired
58	    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder, UserMapper userMapper, JwtEncoder jwtEncoder) {
59	        this.userRepository = userRepository;
60	        this.passwordEncoder = passwordEncoder;
61	        this.userMapper = userMapper;
62	        this.jwtEncoder = jwtEncoder;
63	    }
64	
65	    @Override
66	    public PagedResponse<UserResponse> listAll(Pageable pageable) {
67	        LOG.debug("--> listAll, page={}, size={}", pageable.getPageNumber(), pageable.getPageSize());
68	        final Page<UserResponse> page = userRepository.findAll(pageable).map(userMapper::toUserResponse);
69	        LOG.debug("<-- listAll, total elements={}, total pages={}", page.getTotalElements(), page.getTotalPages());
70	        return PagedResponse.fromPage(page);
71	    }
72	
73	    @Override
74	    public UserResponse getById(final Long id) {
75	        LOG.debug("--> getById, id: {}", id);
76	        final User existingUserEntity = userRepository.findById(id)
77	                .orElseThrow(() -> {
78	                    LOG.error("<-- getById, User with ID {} not found", id);
79	                    return new ResourceNotFoundException(USER, "id", id);
80	                });
81	
82	        final UserResponse userResponse = userMapper.toUserResponse(existingUserEntity);
83	        LOG.debug("<-- getById, user found: {}", userResponse.id());
84	        return userResponse;
85	    }
86	
87	    @Override
88	    public UserResponse getByUsername(final String username) {
89	        LOG.debug("--> getByUsername, username: {}", username);
90	
91	        final User existingUserEntity = userRepository.findByUsername(username)
92	                .orElseThrow(() -> {
93	                    LOG.error("<-- getByUsername, User '{}' not found", username);
94	                    return new ResourceNotFoundException(USER, "username", username);
95	                });
96	
97	        final UserResponse userResponse = userMapper.toUserResponse(existingUserEntity);
98	        LOG.debug("<-- getByUsername, user found: {}", userResponse.id());
99	        return userResponse;
100	    }
101	
102	    @Transactional
103	    @Override
104	    public UserResponse save(final UserRequest userRequest) {
105	        LOG.debug("--> save, user with username: {}", userRequest.username());
106	
107	        if (userRepository.existsByUsername(userRequest.username())) {
108	            LOG.error("<-- save, ResourceAlreadyExistsException for username: {}", userRequest.username());
109	            throw new ResourceAlreadyExistsException(USER, "username", userRequest.username());
110	        }
111	
112	        final User userEntity = userMapper.toUserEntity(userRequest, passwordEncoder);
113	        final User savedUserEntity = userRepository.save(userEntity);
114	        final UserResponse userResponse = userMapper.toUserResponse(savedUserEntity);
115	
116	        LOG.debug("<-- save, user saved with id: {}", userResponse.id());
117	        return userResponse;
118	    }
119	
120	    @Transactional
121	    @Override
122	    public UserResponse update(final Long id, final UserRequest userRequest) {
123	        LOG.debug("--> update, user with id: {}", id);
124	
125	        final User existingUserEntity = userRepository.findById(id)
126	                .orElseThrow(() -> {
127	                    LOG.error("<-- update, User with ID {} not found for update", id);
128	                    return new ResourceNotFoundException(USER, "id", id);
129	                });
130	
131	        final String newName = userRequest.username();
132	        if (newName != null && !newName.isBlank() && !newName.equals(existingUserEntity.getUsername()) && userRepository.existsByUsername(newName)) {
133	            LOG.error("<-- update, failed for user with ID {}. Username '{}' already exists", id, newName);
134	            throw new ResourceAlreadyExistsException(USER, "username", newName);
135	        }
136	
137	        // Partial update via updateUserEntityFromUserRequest
138	        final User updatedUserEntity = userMapper.updateUserEntityFromUserRequest(userRequest, existingUserEntity, passwordEncoder);
139	        final User savedUserEntity = userRepository.save(updatedUserEntity);
140	        final UserResponse userResponse = userMapper.toUserResponse(savedUserEntity);
141	
142	        LOG.debug("<-- update, user updated with id: {}", userResponse.id());
143	        return userResponse;
144	    }
145	
146	    @Transactional
147	    @Override
148	    public void delete(final Long id) {
149	        LOG.debug("--> delete, id: {}", id);
150	
151	        final User existingUserEntity = userRepository.findById(id)
152	                .orElseThrow(() -> {
153	                    LOG.error("<-- delete, User with ID {} not found for deletion", id);
154	                    return new ResourceNotFoundException(USER, "id", id);
155	                });
156	
157	        userRepository.delete(existingUserEntity);
158	        LOG.debug("<-- delete, user with id {} deleted", existingUserEntity.getId());
159	    }
160	
161	    @Override
162	    public LoginResponse checkLogin(final LoginRequest loginRequest) {
163	        LOG.debug("--> checkLogin");
164	        final String username = loginRequest.username();
165	        final String password = Objects.requireNonNullElse(loginRequest.password(), "");
166	
167	        final User user = userRepository.findByUsername(username).orElse(null);
168	
169	        final String hashed = user != null ? user.getPassword() : DUMMY_HASH;
170	        final boolean valid = passwordEncoder.matches(password, hashed);
171	
172	        if (user == null || !valid) {
173	            LOG.warn("<-- checkLogin, FAILED");
174	            throw new UnauthorizedException(USER, "credentials", "invalid");
175	        }
176	
177	        final LoginResponse loginResponse = createLoginResponse(user);
178	        LOG.debug("<-- checkLogin");
179	        return loginResponse;
180	    }
181	
182	    /**
183	     * Creates a {@link LoginResponse} containing a freshly generated JWT token with expiration metadata.
184	     * <p>
185	     * The issued-at and expiration timestamps are calculated once to ensure perfect consistency between
186	     * the values embedded in the JWT and those returned to the client.
187	     *
188	     * @param user the authenticated user
189	     * @return a {@link LoginResponse} with the JWT token, exact expiration instant and remaining seconds
190	     */
191	    private LoginResponse createLoginResponse(final User user) {
192	        LOG.debug("--> createLoginResponse, for username: {}", user.getUsername());
193	        final Instant issuedAt = Instant.now();
194	        final Instant expiresAt = issuedAt.plus(jwtExpirationHours, ChronoUnit.HOURS);
195	        final long expiresInSeconds = Duration.between(issuedAt, expiresAt).getSeconds();
196	        final String token = generateJwtToken(user, issuedAt, expiresAt);
197	        final LoginResponse loginResponse = new LoginResponse(token, expiresAt, expiresInSeconds);
198	        LOG.debug("<-- createLoginResponse, for username: {}", user.getUsername());
199	        return loginResponse;
200	    }
201	
202	    /**
203	     * Generates a signed HS256 JWT for the given user using the provided timestamps.
204	     * <p>
205	     * The token contains:
206	     * <ul>
207	     *   <li>{@code iss} – configured issuer</li>
208	     *   <li>{@code iat} – issued-at timestamp</li>
209	     *   <li>{@code exp} – expiration timestamp</li>
210	     *   <li>{@code sub} – user ID</li>
211	     *   <li>{@code scope} – {@code ROLE_ADMIN} or {@code ROLE_USER}</li>
212	     * </ul>
213	     *
214	     * @param user      the user to issue the token for
215	     * @param issuedAt  exact issuance instant (must match the one used externally)
216	     * @param expiresAt exact expiration instant (must match the one used externally)
217	     * @return the compact JWT string
218	     */
219	    private String generateJwtToken(User user, Instant issuedAt, Instant expiresAt) {
220	        LOG.debug("--> generateJwtToken, for username: {}", user.getUsername());
221	        final String scope = user.isAdmin() ? Role.ADMIN.name() : Role.USER.name();
222	
223	        final JwtClaimsSet claims = JwtClaimsSet.builder()
224	                .issuer(jwtIssuer)
225	                .issuedAt(issuedAt)
226	                .expiresAt(expiresAt)
227	                .subject(String.valueOf(user.getId()))
228	                .claim("scope", scope)
229	                .build();
230	
231	        final String token = jwtEncoder.encode(JwtEncoderParameters.from(JwsHeader.with(MacAlgorithm.HS256).build(), claims)).getTokenValue();
232	        LOG.debug("<-- generateJwtToken, for username: {}", user.getUsername());
233	        return token;
234	    }
235	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/interfaces/AddressService.java =====

1	package com.llmquality.baseline.service.interfaces;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.dto.PagedResponse;
6	import com.llmquality.baseline.entity.Address;
7	import org.springframework.data.domain.Pageable;
8	
9	
10	/**
11	 * Service interface for managing {@link Address} entities and performing
12	 * address-related operations for users, such as creating, updating, retrieving,
13	 * and deleting addresses.
14	 */
15	public interface AddressService {
16	
17	    /**
18	     * Retrieves a paginated list of all addresses for a specific user.
19	     *
20	     * @param userId   the ID of the user whose addresses are to be fetched
21	     * @param pageable pagination details such as page number and size
22	     * @return a {@link PagedResponse} containing a list of {@link AddressResponse} objects
23	     */
24	    PagedResponse<AddressResponse> listAll(Long userId, Pageable pageable);
25	
26	    /**
27	     * Retrieves an address by its ID for a specific user.
28	     *
29	     * @param userId    the ID of the user whose address is to be retrieved
30	     * @param addressId the ID of the address to retrieve
31	     * @return the corresponding {@link AddressResponse} for the given address ID
32	     */
33	    AddressResponse getById(Long userId, Long addressId);
34	
35	    /**
36	     * Creates a new address for a specific user.
37	     *
38	     * @param userId         the ID of the user for whom the address is to be created
39	     * @param addressRequest the request object containing address details to be saved
40	     * @return the newly created {@link AddressResponse}
41	     */
42	    AddressResponse save(Long userId, AddressRequest addressRequest);
43	
44	    /**
45	     * Updates an existing address for a specific user.
46	     *
47	     * @param userId         the ID of the user whose address is to be updated
48	     * @param addressId      the ID of the address to update
49	     * @param addressRequest the request object containing updated address details
50	     * @return the updated {@link AddressResponse}
51	     */
52	    AddressResponse update(Long userId, Long addressId, AddressRequest addressRequest);
53	
54	    /**
55	     * Deletes an address for a specific user.
56	     *
57	     * @param userId    the ID of the user whose address is to be deleted
58	     * @param addressId the ID of the address to delete
59	     */
60	    void delete(Long userId, Long addressId);
61	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/interfaces/CRUDable.java =====

1	package com.llmquality.baseline.service.interfaces;
2	
3	import com.llmquality.baseline.dto.PagedResponse;
4	import org.springframework.data.domain.Pageable;
5	
6	
7	/**
8	 * Generic CRUD interface with standard type parameter naming conventions:
9	 * <ul>
10	 *     <li>R: Request / Input DTO type</li>
11	 *     <li>S: Response / Output DTO type</li>
12	 * </ul>
13	 *
14	 * @param <R> the type of the DTO used for create/update requests
15	 * @param <S> the type of the DTO returned in responses without sensitive data
16	 */
17	public interface CRUDable<R, S> {
18	
19	    /**
20	     * Retrieves a paginated list of entities as response DTOs.
21	     *
22	     * <p>The result includes the content for the requested page along with
23	     * pagination metadata such as total elements, total pages, and whether
24	     * the current page is the last one.</p>
25	     *
26	     * <p>Sorting is disabled in this method; only paging parameters (page number
27	     * and page size) are considered.</p>
28	     *
29	     * @param pageable the pagination information (page number and page size)
30	     * @return a {@link PagedResponse} containing the content and pagination metadata
31	     */
32	    PagedResponse<S> listAll(Pageable pageable);
33	
34	    /**
35	     * Retrieves an entity by its unique identifier.
36	     *
37	     * @param id the ID of the entity to retrieve
38	     * @return the entity represented as a response DTO
39	     */
40	    S getById(Long id);
41	
42	    /**
43	     * Saves a new entity from a request DTO.
44	     *
45	     * @param requestDTO the DTO containing data to create the entity
46	     * @return the saved entity represented as a response DTO
47	     */
48	    S save(R requestDTO);
49	
50	    /**
51	     * Updates an existing entity by ID using a request DTO.
52	     *
53	     * @param id         the ID of the entity to update
54	     * @param requestDTO the DTO containing updated data
55	     * @return the updated entity represented as a response DTO
56	     */
57	    S update(Long id, R requestDTO);
58	
59	    /**
60	     * Deletes an entity by its unique identifier.
61	     *
62	     * @param id the ID of the entity to delete
63	     */
64	    void delete(Long id);
65	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/interfaces/UserService.java =====

1	package com.llmquality.baseline.service.interfaces;
2	
3	import com.llmquality.baseline.dto.LoginRequest;
4	import com.llmquality.baseline.dto.LoginResponse;
5	import com.llmquality.baseline.dto.UserRequest;
6	import com.llmquality.baseline.dto.UserResponse;
7	import com.llmquality.baseline.entity.User;
8	
9	
10	/**
11	 * Service interface for managing {@link User} entities and performing
12	 * user-related operations such as authentication and lookup.
13	 * <p>
14	 * Extends {@link CRUDable} to provide standard Create, Read, Update,
15	 * and Delete operations for {@link UserResponse}/{@link User} objects.
16	 * </p>
17	 */
18	public interface UserService extends CRUDable<UserRequest, UserResponse> {
19	
20	    /**
21	     * Validates user credentials and returns the login result.
22	     *
23	     * @param loginRequest the login request containing username and password
24	     * @return a {@link LoginResponse} indicating whether authentication was successful
25	     */
26	    LoginResponse checkLogin(LoginRequest loginRequest);
27	
28	    /**
29	     * Retrieves a user by their username.
30	     *
31	     * @param username username the username to search for
32	     * @return the corresponding {@link UserResponse}
33	     */
34	    UserResponse getByUsername(String username);
35	}
