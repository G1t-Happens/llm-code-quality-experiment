detected_id,filename,det_lines,error_description
E007,AddressController,"(44, 47)","The create endpoint is declared with consumes=""text/plain"" even though it expects a JSON-mapped AddressRequest body, causing standard application/json requests to be rejected with HTTP 415 and preventing address creation."
E008,UserController,"(47, 51)","The user creation method accepts UserRequest without @Valid/@Validated(Create.class), so none of the DTO constraints ever execute and invalid usernames/passwords/emails can be persisted unchecked."
E015,UserController,"(59, 61)","The DELETE /users/{id} endpoint lacks any @PreAuthorize guard, allowing any caller (even unauthenticated in some setups) to delete arbitrary users, which is a severe authorization vulnerability."
E012,AddressServiceImpl,"(65, 74)",getById calls addressRepository.findById(...).get() without guarding the Optional; a missing address results in NoSuchElementException and a 500 response instead of the documented ResourceNotFoundException.
E003,AddressServiceImpl,"(78, 88)","save() maps the DTO to an Address and immediately maps it back to a response without ever calling addressRepository.save(...), so the address is never persisted and the returned id remains null despite logging that it was saved."
E001,UserMapper,"(55, 56)","updateUserEntityFromUserRequest encodes the password twice (passwordEncoder.encode(passwordEncoder.encode(dto.password()))) which produces hashes that will never match the single-encoded login comparisons, breaking password updates."
E004,UserServiceImpl,"(72, 81)","listAll ignores the supplied Pageable and loads the entire user table into memory (userRepository.findAll()) before wrapping it in a PageImpl, so page number, size, and sorting parameters have no effect and memory usage grows with the table."
E013,UserServiceImpl,"(98, 108)","getByUsername constructs a native SQL string via concatenation (""SELECT * FROM users WHERE username = '"" + username + ""'"") and hands it to the EntityManager, making the endpoint trivially vulnerable to SQL injection and breaking input sanitization."
E014,UserServiceImpl,"(117, 119)","The save method logs both the username and the raw password with LOG.debug(""--> save, user with name: {} and password: {}"", ...), leaking sensitive credentials into application logs and violating security best practices."
E002,UserServiceImpl,"(161, 173)","delete(Long id) fetches the entity and logs success but never calls userRepository.delete(...), so user records are never actually removed and clients receive a false confirmation."
E010,UserServiceImpl,"(175, 189)","checkLogin invokes userRepository.findByUsername(...).get() and only afterwards checks if the user is null, so unknown usernames throw NoSuchElementException and return 500 responses instead of the intended UnauthorizedException with dummy-hash timing protection."
