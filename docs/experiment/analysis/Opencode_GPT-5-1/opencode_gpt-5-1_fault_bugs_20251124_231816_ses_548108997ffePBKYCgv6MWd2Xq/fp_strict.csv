filename,det_lines,error_description
GlobalExceptionHandler.java,"(47, 51)","Nonmalicious human-made development fault with potential information disclosure: handleMalformedJson(HttpMessageNotReadableException) (lines 47–51) returns an ErrorResponse message concatenating ex.getMostSpecificCause().getMessage(). Parser messages may include internal class names, field paths, or unexpected input fragments, which can leak implementation details or sensitive snippets back to clients. This is a dormant confidentiality risk that may activate when malformed JSON is sent maliciously for reconnaissance."
SecurityConfig.java,"(66, 67)","Nonmalicious human-made configuration/development fault around JWT secret handling: SecurityConfig.securityFilterChain plus createSecretKey(String base64Secret) (lines 66–67 and 107–109) assume jwt.secret is a Base64-encoded key. If operators follow typical documentation patterns and configure a raw string (not Base64), Base64.getDecoder().decode(jwtSecret) will throw IllegalArgumentException at startup, preventing the application from booting (halt failure). This is a latent configuration fault whose activation depends on deployment practices and documentation clarity."
UserServiceImpl.java,"(125, 153)","Nonmalicious human-made development software design/maintainability fault: save(UserRequest) and update(Long, UserRequest) (lines 125–126 and 152–153) instantiate new BCryptPasswordEncoder instances instead of consistently using the injected PasswordEncoder bean configured in SecurityConfig. While behavior currently matches, this duplication is a dormant fault that can activate if the global encoder configuration changes (e.g., different algorithm or strength), leading to mismatched password hashes and authentication failures for newly created/updated users versus existing ones."
UserServiceImpl.java,"(176, 189)","Nonmalicious human-made development logic fault in authentication flow: checkLogin(LoginRequest) (lines 176–189) calls userRepository.findByUsername(username).get() on an Optional without presence check (line 181). For unknown usernames, this throws NoSuchElementException before hashing, bypassing the intended DUMMY_HASH timing-attack mitigation. The resulting unhandled exception surfaces as HTTP 500 instead of 401, enabling username enumeration (different timing/HTTP code) and causing erratic failures instead of controlled UnauthorizedException-based responses."
AddressServiceImpl.java,"(65, 73)","Nonmalicious human-made development logic fault in resource lookup: getById(Long userId, Long addressId) (lines 65–73) dereferences addressRepository.findById(addressId).get() without an orElseThrow wrapper. When addressId does not exist, this causes NoSuchElementException, yielding an HTTP 500 via the default error handling instead of a controlled 404 ResourceNotFoundException, leading to erratic failure and potential information leakage about internal exception types."
