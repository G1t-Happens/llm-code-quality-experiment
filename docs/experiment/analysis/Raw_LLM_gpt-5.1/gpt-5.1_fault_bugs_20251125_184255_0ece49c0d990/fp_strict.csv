filename,det_lines,error_description
UserServiceImpl.java,"(117, 132)","save() logs both username and raw password (""user with name: {} and password: {}""), and uses a new BCryptPasswordEncoder instead of the injected PasswordEncoder. Logging plaintext passwords is a severe confidentiality breach; using a separate encoder instance can cause configuration drift (e.g., different strength) and undermines central security configuration (nonmalicious development fault)."
UserServiceImpl.java,"(133, 159)","update() similarly instantiates a new BCryptPasswordEncoder instead of using the injected PasswordEncoder, and relies on UserMapper.updateUserEntityFromUserRequest(), which double-encodes passwords. This combination leads to inconsistent hashing behavior and broken authentication after updates (nonmalicious development fault)."
UserServiceImpl.java,"(176, 189)","checkLogin() calls userRepository.findByUsername(username).get() without checking presence, which will throw NoSuchElementException for unknown users, bypassing the intended UnauthorizedException and leaking timing/behavior differences. Additionally, the DUMMY_HASH constant is never used because user is never null at the check; this defeats the timing-attack mitigation and constitutes a logic fault in authentication error handling."
UserServiceImpl.java,"(205, 213)","createLoginResponse() and generateJwtToken() rely on injected jwtIssuer and jwtExpirationHours without validation; misconfiguration (e.g., negative expiration) could produce already-expired tokens. This is a latent configuration/validation fault that can cause intermittent authentication failures."
UserRequest.java,"(21, 26)","Password field is validated only for presence and complexity but not for leading/trailing whitespace or overall maximum length semantics; combined with logging in UserServiceImpl.save(), this increases risk of accidental sensitive-data exposure and inconsistent credential handling (latent design fault)."
SecurityConfig.java,"(60, 76)","SecurityFilterChain permits POST {api.base-path}/users for unauthenticated callers while UserController.create() allows setting the admin flag gated only by @sec.canSetAdminFlag, which relies on Authentication; for anonymous users auth is null, but the expression still allows admin=false. This design permits unrestricted self-registration as non-admin but, combined with other flaws (e.g., missing delete authorization), increases attack surface. Additionally, CSRF is fully disabled, which is acceptable for pure APIs but becomes a fault if used from browsers without proper token-based protection."
SecurityExpressions.java,"(18, 23)","isOwner(Long resourceOwnerId, Authentication auth) compares resourceOwnerId.toString() to auth.getName(), assuming the principal name equals the numeric user ID. If the Authentication implementation uses username as principal (default for many setups), this check will always fail, causing legitimate owners to be denied access (nonmalicious design fault in authorization logic)."
User.java,"(19, 20)","Password column is limited to length 60, which is tight for BCrypt hashes and may be incompatible with alternative encoders or configuration changes; this is a latent schema design fault that can cause truncation errors or authentication failures if encoder output length changes."
AddressServiceImpl.java,"(65, 73)","getById() calls addressRepository.findById(addressId).get() without checking presence. If the address does not exist, this throws NoSuchElementException, bypassing the intended ResourceNotFoundException and resulting in a 500 Internal Server Error instead of 404, a nonmalicious development fault in error handling."
LoggingConfig.java,"(51, 79)","LoggingConfig hardcodes default log directory and patterns, and uses @Value(""${logging.file.name:application:errors.log}"") with a colon in the default filename, which may create an invalid path on some platforms; this is a nonmalicious development/configuration fault that can cause logging initialization errors or logs written to unexpected locations."
UserRepository.java,"(12, 15)",UserRepository lacks a method to check for email uniqueness despite email likely being a logical unique identifier; this omission is a latent design fault that can allow duplicate emails and complicate account recovery or identification flows.
