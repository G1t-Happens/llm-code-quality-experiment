filename,start_line,end_line,error_description,semantically_correct_detected
AddressController.java,44,48,"POST /users/{userId}/addresses is restricted to text/plain via consumes=""text/plain"" although the handler expects a JSON body mapped to AddressRequest. Standard application/json requests therefore receive 415/HttpMessageNotReadable responses and no address can be created unless the client sends an incorrect content type.",
AddressController.java,50,53,"The PATCH /users/{userId}/addresses/{addressId} handler does not annotate the request body with @Validated(AddressValidationGroups.Update), so update payloads bypass bean validation. Invalid or blank fields are accepted and persisted, contradicting the DTO constraints for updates.",
UserController.java,47,51,"The create user endpoint lacks @Validated(UserValidationGroups.Create) on the request body, so none of the mandatory validation constraints on UserRequest ever run during user creation and malformed data (empty username/password/email or admin null) can be stored.",
UserController.java,59,62,"DELETE /users/{id} has no @PreAuthorize guard, meaning any authenticated caller can delete any user record regardless of role or ownership, bypassing the security policy enforced on all other user endpoints.",
AddressServiceImpl.java,65,73,"getById retrieves an address via addressRepository.findById(addressId).get(); when the ID does not exist, a NoSuchElementException propagates as a 500 response instead of returning the expected ResourceNotFoundException (404) and also skips the ownership check.",
AddressServiceImpl.java,78,89,save() maps the DTO to an Address entity but never calls addressRepository.save(...). As a result no row is persisted and the returned AddressResponse always contains a null id despite the log claiming it was saved.,
UserMapper.java,53,56,"updateUserEntityFromUserRequest encodes passwords twice (`passwordEncoder.encode(passwordEncoder.encode(dto.password()))`). Updated users receive double-hashed passwords that will never match during login, effectively locking them out after any update that includes a password.",
UserServiceImpl.java,71,82,"listAll(Pageable) ignores the supplied Pageable and loads the entire table with userRepository.findAll(), then wraps the full result list in a PageImpl. Requests for later pages or smaller page sizes still return every user, breaking pagination semantics and risking large-memory responses.",
UserServiceImpl.java,99,108,getByUsername builds a native SQL string by concatenating the username (`SELECT * FROM users WHERE username = '...')`) and executes it without parameters. This makes the endpoint vulnerable to SQL injection and bypasses the type-safe repository method that already exists.,
UserServiceImpl.java,118,124,"save() logs the raw password (`... password: {}`) before hashing, leaking user credentials into application logs and violating basic security practices.",
UserServiceImpl.java,161,173,"delete() verifies the user exists but never invokes userRepository.delete(...) or deleteById, so it reports success while leaving the row untouched.",
UserServiceImpl.java,175,189,"checkLogin() calls userRepository.findByUsername(username).get() without checking presence. Missing users cause NoSuchElementException and a 500 response, and the dummy hash intended to mitigate timing attacks is never used. The method should fall back to the dummy hash and throw UnauthorizedException instead of blowing up.",
