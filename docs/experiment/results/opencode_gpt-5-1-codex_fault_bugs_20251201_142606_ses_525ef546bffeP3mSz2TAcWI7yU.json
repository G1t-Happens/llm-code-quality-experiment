{
  "_metadata": {
    "source_file": "session-ses_525e.md",
    "model": "gpt.5.1.codex",
    "session_id": "ses_525ef546bffeP3mSz2TAcWI7yU",
    "processed_at": "2025-12-01T14:26:06.894162",
    "total_tokens": 65748,
    "time_taken_seconds": 425,
    "bug_count": 12
  },
  "bugs": [
    {
      "filename": "src/main/java/com/llmquality/baseline/controller/AddressController.java",
      "start_line": 44,
      "end_line": 48,
      "error_description": "POST /users/{userId}/addresses is restricted to text/plain via consumes=\"text/plain\" although the handler expects a JSON body mapped to AddressRequest. Standard application/json requests therefore receive 415/HttpMessageNotReadable responses and no address can be created unless the client sends an incorrect content type."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/controller/AddressController.java",
      "start_line": 50,
      "end_line": 53,
      "error_description": "The PATCH /users/{userId}/addresses/{addressId} handler does not annotate the request body with @Validated(AddressValidationGroups.Update), so update payloads bypass bean validation. Invalid or blank fields are accepted and persisted, contradicting the DTO constraints for updates."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/controller/UserController.java",
      "start_line": 47,
      "end_line": 51,
      "error_description": "The create user endpoint lacks @Validated(UserValidationGroups.Create) on the request body, so none of the mandatory validation constraints on UserRequest ever run during user creation and malformed data (empty username/password/email or admin null) can be stored."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/controller/UserController.java",
      "start_line": 59,
      "end_line": 62,
      "error_description": "DELETE /users/{id} has no @PreAuthorize guard, meaning any authenticated caller can delete any user record regardless of role or ownership, bypassing the security policy enforced on all other user endpoints."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/AddressServiceImpl.java",
      "start_line": 65,
      "end_line": 73,
      "error_description": "getById retrieves an address via addressRepository.findById(addressId).get(); when the ID does not exist, a NoSuchElementException propagates as a 500 response instead of returning the expected ResourceNotFoundException (404) and also skips the ownership check."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/AddressServiceImpl.java",
      "start_line": 78,
      "end_line": 89,
      "error_description": "save() maps the DTO to an Address entity but never calls addressRepository.save(...). As a result no row is persisted and the returned AddressResponse always contains a null id despite the log claiming it was saved."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/mapper/UserMapper.java",
      "start_line": 53,
      "end_line": 56,
      "error_description": "updateUserEntityFromUserRequest encodes passwords twice (`passwordEncoder.encode(passwordEncoder.encode(dto.password()))`). Updated users receive double-hashed passwords that will never match during login, effectively locking them out after any update that includes a password."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
      "start_line": 71,
      "end_line": 82,
      "error_description": "listAll(Pageable) ignores the supplied Pageable and loads the entire table with userRepository.findAll(), then wraps the full result list in a PageImpl. Requests for later pages or smaller page sizes still return every user, breaking pagination semantics and risking large-memory responses."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
      "start_line": 99,
      "end_line": 108,
      "error_description": "getByUsername builds a native SQL string by concatenating the username (`SELECT * FROM users WHERE username = '...')`) and executes it without parameters. This makes the endpoint vulnerable to SQL injection and bypasses the type-safe repository method that already exists."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
      "start_line": 118,
      "end_line": 124,
      "error_description": "save() logs the raw password (`... password: {}`) before hashing, leaking user credentials into application logs and violating basic security practices."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
      "start_line": 161,
      "end_line": 173,
      "error_description": "delete() verifies the user exists but never invokes userRepository.delete(...) or deleteById, so it reports success while leaving the row untouched."
    },
    {
      "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
      "start_line": 175,
      "end_line": 189,
      "error_description": "checkLogin() calls userRepository.findByUsername(username).get() without checking presence. Missing users cause NoSuchElementException and a 500 response, and the dummy hash intended to mitigate timing attacks is never used. The method should fall back to the dummy hash and throw UnauthorizedException instead of blowing up."
    }
  ]
}