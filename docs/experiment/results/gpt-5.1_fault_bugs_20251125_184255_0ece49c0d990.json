[
  {
    "filename": "src/main/java/com/llmquality/baseline/controller/AddressController.java",
    "start_line": 44,
    "end_line": 48,
    "severity": "medium",
    "error_description": "@PostMapping for create() declares consumes = \"text/plain\" while the method expects a JSON-mapped AddressRequest body; this content-type mismatch will cause HttpMessageNotReadableException for typical JSON clients and represents a nonmalicious development fault in API contract configuration."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/controller/UserController.java",
    "start_line": 59,
    "end_line": 61,
    "severity": "high",
    "error_description": "delete() endpoint lacks any @PreAuthorize constraint, allowing any authenticated principal (or potentially unauthenticated if other config changes) to delete arbitrary users, which is a human-made, nonmalicious development fault leading to privilege escalation and integrity failure."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/dto/UserRequest.java",
    "start_line": 21,
    "end_line": 26,
    "severity": "medium",
    "error_description": "Password field is validated only for presence and complexity but not for leading/trailing whitespace or overall maximum length semantics; combined with logging in UserServiceImpl.save(), this increases risk of accidental sensitive-data exposure and inconsistent credential handling (latent design fault)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/entity/User.java",
    "start_line": 19,
    "end_line": 20,
    "severity": "medium",
    "error_description": "Password column is limited to length 60, which is tight for BCrypt hashes and may be incompatible with alternative encoders or configuration changes; this is a latent schema design fault that can cause truncation errors or authentication failures if encoder output length changes."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/logging/LoggingConfig.java",
    "start_line": 51,
    "end_line": 79,
    "severity": "low",
    "error_description": "LoggingConfig hardcodes default log directory and patterns, and uses @Value(\"${logging.file.name:application:errors.log}\") with a colon in the default filename, which may create an invalid path on some platforms; this is a nonmalicious development/configuration fault that can cause logging initialization errors or logs written to unexpected locations."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/mapper/UserMapper.java",
    "start_line": 55,
    "end_line": 56,
    "severity": "high",
    "error_description": "updateUserEntityFromUserRequest() maps password with expression passwordEncoder.encode(passwordEncoder.encode(dto.password())), effectively double-encoding the password on updates. This causes stored hashes to be incompatible with single-encode verification, leading to systematic login failures after password change (nonmalicious development fault in mapping logic)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/repository/UserRepository.java",
    "start_line": 12,
    "end_line": 15,
    "severity": "low",
    "error_description": "UserRepository lacks a method to check for email uniqueness despite email likely being a logical unique identifier; this omission is a latent design fault that can allow duplicate emails and complicate account recovery or identification flows."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/security/SecurityConfig.java",
    "start_line": 60,
    "end_line": 76,
    "severity": "high",
    "error_description": "SecurityFilterChain permits POST {api.base-path}/users for unauthenticated callers while UserController.create() allows setting the admin flag gated only by @sec.canSetAdminFlag, which relies on Authentication; for anonymous users auth is null, but the expression still allows admin=false. This design permits unrestricted self-registration as non-admin but, combined with other flaws (e.g., missing delete authorization), increases attack surface. Additionally, CSRF is fully disabled, which is acceptable for pure APIs but becomes a fault if used from browsers without proper token-based protection."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/security/SecurityExpressions.java",
    "start_line": 18,
    "end_line": 23,
    "severity": "medium",
    "error_description": "isOwner(Long resourceOwnerId, Authentication auth) compares resourceOwnerId.toString() to auth.getName(), assuming the principal name equals the numeric user ID. If the Authentication implementation uses username as principal (default for many setups), this check will always fail, causing legitimate owners to be denied access (nonmalicious design fault in authorization logic)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/AddressServiceImpl.java",
    "start_line": 65,
    "end_line": 73,
    "severity": "high",
    "error_description": "getById() calls addressRepository.findById(addressId).get() without checking presence. If the address does not exist, this throws NoSuchElementException, bypassing the intended ResourceNotFoundException and resulting in a 500 Internal Server Error instead of 404, a nonmalicious development fault in error handling."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/AddressServiceImpl.java",
    "start_line": 75,
    "end_line": 89,
    "severity": "high",
    "error_description": "save() maps AddressRequest to Address entity but never calls addressRepository.save(addressEntity); it directly maps the transient entity to AddressResponse and returns it. This omission means addresses are never persisted, causing silent data loss and inconsistent behavior (critical omission fault in persistence logic)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 72,
    "end_line": 82,
    "severity": "medium",
    "error_description": "listAll(Pageable pageable) ignores the Pageable when querying the database (userRepository.findAll()) and then wraps all results in a PageImpl with the requested pageable. This can load the entire user table into memory, breaking pagination semantics and causing performance/scalability failures (nonmalicious design fault)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 99,
    "end_line": 107,
    "severity": "critical",
    "error_description": "getByUsername() constructs a native SQL query via string concatenation: \"SELECT * FROM users WHERE username = '\" + username + \"'\". This is a classic SQL injection vulnerability (human-made, nonmalicious development fault) allowing attackers to inject arbitrary SQL via the username parameter, potentially leading to data exfiltration or modification."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 117,
    "end_line": 132,
    "severity": "high",
    "error_description": "save() logs both username and raw password (\"user with name: {} and password: {}\"), and uses a new BCryptPasswordEncoder instead of the injected PasswordEncoder. Logging plaintext passwords is a severe confidentiality breach; using a separate encoder instance can cause configuration drift (e.g., different strength) and undermines central security configuration (nonmalicious development fault)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 133,
    "end_line": 159,
    "severity": "medium",
    "error_description": "update() similarly instantiates a new BCryptPasswordEncoder instead of using the injected PasswordEncoder, and relies on UserMapper.updateUserEntityFromUserRequest(), which double-encodes passwords. This combination leads to inconsistent hashing behavior and broken authentication after updates (nonmalicious development fault)."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 162,
    "end_line": 173,
    "severity": "high",
    "error_description": "delete() loads the User entity but never calls userRepository.delete(existingUserEntity) or deleteById(id); it only logs that the user was deleted. This omission fault means users are never actually removed, causing latent data retention and violating expected service semantics."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 176,
    "end_line": 189,
    "severity": "critical",
    "error_description": "checkLogin() calls userRepository.findByUsername(username).get() without checking presence, which will throw NoSuchElementException for unknown users, bypassing the intended UnauthorizedException and leaking timing/behavior differences. Additionally, the DUMMY_HASH constant is never used because user is never null at the check; this defeats the timing-attack mitigation and constitutes a logic fault in authentication error handling."
  },
  {
    "filename": "src/main/java/com/llmquality/baseline/service/UserServiceImpl.java",
    "start_line": 205,
    "end_line": 213,
    "severity": "low",
    "error_description": "createLoginResponse() and generateJwtToken() rely on injected jwtIssuer and jwtExpirationHours without validation; misconfiguration (e.g., negative expiration) could produce already-expired tokens. This is a latent configuration/validation fault that can cause intermittent authentication failures."
  }
]