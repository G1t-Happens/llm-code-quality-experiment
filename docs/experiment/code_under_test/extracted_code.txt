
===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/build.gradle =====

1	plugins {
2		id 'java'
3		id 'org.springframework.boot' version '3.5.7'
4		id 'io.spring.dependency-management' version '1.1.7'
5	}
6	
7	group = 'com.llmquality'
8	version = '0.0.1-SNAPSHOT'
9	description = 'Spring Boot reference application for LLM-based software quality experiment (ISO/IEC 25010)'
10	
11	java {
12		toolchain {
13			languageVersion = JavaLanguageVersion.of(21)
14		}
15	}
16	
17	repositories {
18		mavenCentral()
19	}
20	
21	dependencies {
22		implementation 'org.springframework.boot:spring-boot-starter-actuator'
23		implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
24		implementation 'org.springframework.boot:spring-boot-starter-validation'
25		implementation 'org.springframework.boot:spring-boot-starter-web'
26	    implementation 'org.springframework.boot:spring-boot-starter-security'
27	    implementation 'org.springframework.security:spring-security-oauth2-resource-server'
28	    implementation 'org.springframework.security:spring-security-oauth2-jose'
29	    implementation 'org.flywaydb:flyway-core'
30	    implementation 'org.flywaydb:flyway-database-postgresql'
31	    implementation 'me.paulschwarz:spring-dotenv:4.0.0'
32	    implementation 'org.mapstruct:mapstruct:1.6.3'
33	    annotationProcessor 'org.mapstruct:mapstruct-processor:1.6.3'
34	    runtimeOnly 'org.postgresql:postgresql'
35		developmentOnly 'org.springframework.boot:spring-boot-devtools'
36		testImplementation 'org.springframework.boot:spring-boot-starter-test'
37		testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
38	}
39	
40	tasks.named('test') {
41		useJUnitPlatform()
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/settings.gradle =====

1	rootProject.name = 'baseline-project'

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/BaselineProjectApplication.java =====

1	package com.llmquality.baseline;
2	
3	import org.springframework.boot.SpringApplication;
4	import org.springframework.boot.autoconfigure.SpringBootApplication;
5	import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
6	
7	@SpringBootApplication
8	@EnableMethodSecurity
9	public class BaselineProjectApplication {
10	    public static void main(String[] args) {
11	        SpringApplication.run(BaselineProjectApplication.class, args);
12	    }
13	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/controller/AddressController.java =====

1	package com.llmquality.baseline.controller;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.dto.PagedResponse;
6	import com.llmquality.baseline.service.interfaces.AddressService;
7	import org.springframework.beans.factory.annotation.Autowired;
8	import org.springframework.data.domain.Pageable;
9	import org.springframework.data.domain.Sort;
10	import org.springframework.data.web.PageableDefault;
11	import org.springframework.security.access.prepost.PreAuthorize;
12	import org.springframework.validation.annotation.Validated;
13	import org.springframework.web.bind.annotation.*;
14	
15	import static com.llmquality.baseline.dto.validation.AddressValidationGroups.*;
16	
17	
18	@RestController
19	@RequestMapping("${api.base-path}/users/{userId}/addresses")
20	public class AddressController {
21	
22	    private final AddressService addressService;
23	
24	    @Autowired
25	    public AddressController(AddressService addressService) {
26	        this.addressService = addressService;
27	    }
28	
29	
30	    @GetMapping
31	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
32	    public PagedResponse<AddressResponse> listAll(
33	            @PathVariable Long userId,
34	            @PageableDefault(sort = "id", direction = Sort.Direction.ASC) Pageable pageable) {
35	        return addressService.listAll(userId, pageable);
36	    }
37	
38	    @GetMapping("/{addressId}")
39	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
40	    public AddressResponse getById(@PathVariable Long userId, @PathVariable Long addressId) {
41	        return addressService.getById(userId, addressId);
42	    }
43	
44	    @PostMapping(consumes = "text/plain")
45	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
46	    public AddressResponse create(@PathVariable Long userId, @RequestBody @Validated(Create.class) AddressRequest addressRequest) {
47	        return addressService.save(userId, addressRequest);
48	    }
49	
50	    @PatchMapping("/{addressId}")
51	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
52	    public AddressResponse update(@PathVariable Long userId, @PathVariable Long addressId, @RequestBody @Validated(Update.class) AddressRequest addressRequest) {
53	        return addressService.update(userId, addressId, addressRequest);
54	    }
55	
56	    @DeleteMapping("/{addressId}")
57	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#userId, authentication)")
58	    public void delete(@PathVariable Long userId, @PathVariable Long addressId) {
59	        addressService.delete(userId, addressId);
60	    }
61	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/controller/UserController.java =====

1	package com.llmquality.baseline.controller;
2	
3	import com.llmquality.baseline.dto.*;
4	import com.llmquality.baseline.service.interfaces.UserService;
5	import jakarta.validation.Valid;
6	import org.springframework.beans.factory.annotation.Autowired;
7	import org.springframework.data.domain.Pageable;
8	import org.springframework.data.domain.Sort;
9	import org.springframework.data.web.PageableDefault;
10	import org.springframework.security.access.prepost.PreAuthorize;
11	import org.springframework.validation.annotation.Validated;
12	import org.springframework.web.bind.annotation.*;
13	
14	import static com.llmquality.baseline.dto.validation.UserValidationGroups.*;
15	
16	
17	@RestController
18	@RequestMapping("${api.base-path}/users")
19	public class UserController {
20	
21	    private final UserService userService;
22	
23	    @Autowired
24	    public UserController(UserService userService) {
25	        this.userService = userService;
26	    }
27	
28	
29	    @GetMapping
30	    @PreAuthorize("hasRole('ADMIN')")
31	    public PagedResponse<UserResponse> listAll(@PageableDefault(sort = "id", direction = Sort.Direction.ASC) Pageable pageable) {
32	        return userService.listAll(pageable);
33	    }
34	
35	    @GetMapping("/{id}")
36	    @PreAuthorize("hasRole('ADMIN') or @sec.isOwner(#id, authentication)")
37	    public UserResponse getById(@PathVariable Long id) {
38	        return userService.getById(id);
39	    }
40	
41	    @GetMapping("/search")
42	    @PreAuthorize("hasRole('ADMIN')")
43	    public UserResponse getByUsername(@RequestParam("username") String username) {
44	        return userService.getByUsername(username);
45	    }
46	
47	    @PostMapping
48	    @PreAuthorize("hasRole('ADMIN') or @sec.canSetAdminFlag(#userRequest.admin, authentication)")
49	    public UserResponse create(@RequestBody UserRequest userRequest) {
50	        return userService.save(userRequest);
51	    }
52	
53	    @PatchMapping("/{id}")
54	    @PreAuthorize("hasRole('ADMIN') or (@sec.isOwner(#id, authentication) and @sec.canSetAdminFlag(#userRequest.admin, authentication))")
55	    public UserResponse update(@PathVariable Long id, @RequestBody @Validated(Update.class) UserRequest userRequest) {
56	        return userService.update(id, userRequest);
57	    }
58	
59	    @DeleteMapping("/{id}")
60	    public void delete(@PathVariable Long id) {
61	        userService.delete(id);
62	    }
63	
64	    @PostMapping("/login")
65	    public LoginResponse login(@RequestBody @Valid LoginRequest loginRequest) {
66	        return userService.checkLogin(loginRequest);
67	    }
68	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/AddressRequest.java =====

1	package com.llmquality.baseline.dto;
2	
3	import com.llmquality.baseline.enums.AddressType;
4	import jakarta.validation.constraints.*;
5	
6	import static com.llmquality.baseline.dto.validation.AddressValidationGroups.*;
7	
8	
9	/**
10	 * Request DTO for addresses.
11	 * <p>
12	 * This is a Java {@code record}, which is immutable and automatically provides
13	 * a constructor, getter, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
14	 * Introduced in Java 17.
15	 * </p>
16	 */
17	public record AddressRequest(
18	
19	        @NotBlank(groups = Create.class, message = "Street is required on create")
20	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
21	                message = "Street must not be empty or consist only of whitespace")
22	        @Size(max = 255, message = "Street must be at most 255 characters long")
23	        String street,
24	
25	        @NotBlank(groups = Create.class, message = "House number is required on create")
26	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
27	                message = "House number must not be empty or consist only of whitespace")
28	        @Size(max = 255)
29	        String houseNumber,
30	
31	        @NotBlank(groups = Create.class, message = "Postal code is required on create")
32	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
33	                message = "Postal code must not be empty or consist only of whitespace")
34	        @Size(max = 255)
35	        String postalCode,
36	
37	        @NotBlank(groups = Create.class, message = "City is required on create")
38	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
39	                message = "City must not be empty or consist only of whitespace")
40	        @Size(max = 255)
41	        String city,
42	
43	        @NotBlank(groups = Create.class, message = "Country is required on create")
44	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
45	                message = "Country must not be empty or consist only of whitespace")
46	        @Size(max = 255)
47	        String country,
48	
49	        @NotNull(groups = Create.class, message = "Address type is required on create")
50	        AddressType addressType
51	) {
52	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
53	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/AddressResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	import com.llmquality.baseline.enums.AddressType;
4	
5	
6	/**
7	 * Response DTO for addresses.
8	 * <p>
9	 * This is a Java {@code record}, which is immutable and automatically provides
10	 * a constructor, getter, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
11	 * Introduced in Java 17.
12	 * </p>
13	 */
14	public record AddressResponse(
15	
16	        Long id,
17	
18	        String street,
19	
20	        String houseNumber,
21	
22	        String postalCode,
23	
24	        String city,
25	
26	        String country,
27	
28	        AddressType addressType,
29	
30	        Long userId
31	) {
32	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
33	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/LoginRequest.java =====

1	package com.llmquality.baseline.dto;
2	
3	import jakarta.validation.constraints.NotBlank;
4	import jakarta.validation.constraints.Size;
5	
6	
7	/**
8	 * Data Transfer Object (DTO) for user login requests.
9	 * <p>
10	 * Contains the username and password fields with validation constraints
11	 * to ensure non-blank input and enforce maximum length.
12	 * </p>
13	 */
14	public record LoginRequest(
15	
16	        @NotBlank(message = "Username must not be blank")
17	        @Size(max = 255, message = "Username must be at most 255 characters long")
18	        String username,
19	
20	        @NotBlank(message = "Password must not be blank")
21	        @Size(max = 255, message = "Password must be at most 255 characters long")
22	        String password
23	) {
24	    // You can add custom methods here if needed, e.g., convenience methods or formatting helpers.
25	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/LoginResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	
4	/**
5	 * Response DTO for login operations.
6	 * <p>
7	 * This is a Java {@code record}, which is immutable and automatically provides
8	 * a constructor, getter, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
9	 * Introduced in Java 17.
10	 * </p>
11	 */
12	public record LoginResponse(
13	
14	        String token
15	) {
16	    // You can add custom methods here if needed, e.g., convenience methods or formatting helpers.
17	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/PagedResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	import org.springframework.data.domain.Page;
4	
5	import java.util.Collections;
6	import java.util.List;
7	import java.util.Objects;
8	
9	
10	/**
11	 * Generic pagination DTO for REST API responses.
12	 *
13	 * <p>This DTO encapsulates paginated content along with metadata
14	 * about the current page, page size, total elements, total pages,
15	 * and whether the current page is the last one.</p>
16	 *
17	 * <p>This class provides a static factory method {@link #fromPage(Page)}
18	 * to easily convert a {@link Page} from Spring Data JPA into a stable
19	 * response structure suitable for REST APIs.</p>
20	 *
21	 * @param <T> the type of content in the page
22	 */
23	public record PagedResponse<T>(
24	
25	        List<T> content,
26	
27	        int page,
28	
29	        int size,
30	
31	        long totalElements,
32	
33	        int totalPages,
34	
35	        boolean last
36	) {
37	
38	    /**
39	     * Creates a {@code PagedResponse} from a Spring Data {@link Page}.
40	     *
41	     * @param page the {@link Page} containing content and pagination metadata
42	     * @param <T>  the type of the content
43	     * @return a new {@link PagedResponse} with content and pagination info
44	     */
45	    public static <T> PagedResponse<T> fromPage(Page<T> page) {
46	        Objects.requireNonNull(page, "Page must not be null");
47	        return new PagedResponse<>(
48	                Collections.unmodifiableList(page.getContent()),
49	                page.getNumber(),
50	                page.getSize(),
51	                page.getTotalElements(),
52	                page.getTotalPages(),
53	                page.isLast()
54	        );
55	    }
56	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/UserRequest.java =====

1	package com.llmquality.baseline.dto;
2	
3	import jakarta.validation.constraints.*;
4	
5	import static com.llmquality.baseline.dto.validation.UserValidationGroups.*;
6	
7	
8	/**
9	 * Data Transfer Object (DTO) for creating or updating a User.
10	 * <p>
11	 * Contains user input fields with validation annotations for create and update operations.
12	 * </p>
13	 */
14	public record UserRequest(
15	
16	        @NotBlank(groups = Create.class, message = "Username is required")
17	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
18	                message = "Username must not be empty or consist only of whitespace")
19	        String username,
20	
21	        @NotBlank(groups = Create.class, message = "Password is required on create")
22	        @Pattern(regexp = "^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$",
23	                groups = {Create.class, Update.class},
24	                message = "Password must be at least 8 characters, contain number, lowercase and uppercase")
25	        @Size(min = 8, max = 255, groups = {Create.class, Update.class})
26	        String password,
27	
28	        @NotBlank(groups = Create.class, message = "Email is required on create")
29	        @Email(groups = {Create.class, Update.class}, message = "Invalid email format")
30	        @Pattern(regexp = "\\S[\\S\\s]*", groups = Update.class,
31	                message = "Email must not be empty or consist only of whitespace")
32	        String email,
33	
34	        @NotNull(groups = Create.class, message = "Admin flag is required on create")
35	        Boolean admin
36	) {
37	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
38	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/UserResponse.java =====

1	package com.llmquality.baseline.dto;
2	
3	
4	/**
5	 * Response DTO for User information.
6	 * <p>
7	 * This is a Java {@code record}, which is immutable and automatically provides
8	 * a constructor, getters, {@code equals()}, {@code hashCode()}, and {@code toString()} methods.
9	 * Introduced in Java 17.
10	 * </p>
11	 */
12	public record UserResponse(
13	
14	        Long id,
15	
16	        String username,
17	
18	        String email,
19	
20	        Boolean admin
21	
22	) {
23	    // You can add custom methods here if needed, e.g., formatted output or convenience methods.
24	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/validation/AddressValidationGroups.java =====

1	package com.llmquality.baseline.dto.validation;
2	
3	
4	/**
5	 * This class contains a validation group for differentiating between the
6	 * validation rules applied during the creation and update of a addresses.
7	 * <p>
8	 * These groups are used to apply specific validation constraints based on
9	 * the operation (create or update) being performed.
10	 * </p>
11	 *
12	 * <p>
13	 * The purpose of validation groups is to control which validation rules
14	 * are applied depending on the context, preventing unnecessary validations
15	 * for operations that don’t require them e.q. update requests
16	 * </p>
17	 */
18	public final class AddressValidationGroups {
19	
20	    /**
21	     * Private constructor to prevent instantiation of this utility class.
22	     * Throws UnsupportedOperationException if called.
23	     */
24	    private AddressValidationGroups() {
25	        throw new UnsupportedOperationException("Utility class - should not be instantiated");
26	    }
27	
28	    /**
29	     * Validation group for creating a new addresses.
30	     * <p>
31	     * This interface is used to mark the validation constraints that should
32	     * be applied when creating a new address.
33	     * </p>
34	     */
35	    public interface Create {
36	    }
37	
38	    /**
39	     * Validation group for updating an existing addresses.
40	     * <p>
41	     * This interface is used to mark the validation constraints that should
42	     * be applied when updating an address.
43	     * </p>
44	     */
45	    public interface Update {
46	    }
47	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/dto/validation/UserValidationGroups.java =====

1	package com.llmquality.baseline.dto.validation;
2	
3	
4	/**
5	 * This class contains a validation group for differentiating between the
6	 * validation rules applied during the creation and update of a user.
7	 * <p>
8	 * These groups are used to apply specific validation constraints based on
9	 * the operation (create or update) being performed.
10	 * </p>
11	 *
12	 * <p>
13	 * The purpose of validation groups is to control which validation rules
14	 * are applied depending on the context, preventing unnecessary validations
15	 * for operations that don’t require them e.q. update requests
16	 * </p>
17	 */
18	public final class UserValidationGroups {
19	
20	    /**
21	     * Private constructor to prevent instantiation of this utility class.
22	     * Throws UnsupportedOperationException if called.
23	     */
24	    private UserValidationGroups() {
25	        throw new UnsupportedOperationException("Utility class - should not be instantiated");
26	    }
27	
28	    /**
29	     * Validation group for creating a new user.
30	     * <p>
31	     * This interface is used to mark the validation constraints that should
32	     * be applied when creating a new user (e.g., during user registration).
33	     * </p>
34	     */
35	    public interface Create {
36	    }
37	
38	    /**
39	     * Validation group for updating an existing user.
40	     * <p>
41	     * This interface is used to mark the validation constraints that should
42	     * be applied when updating a user.
43	     * </p>
44	     */
45	    public interface Update {
46	    }
47	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/entity/Address.java =====

1	package com.llmquality.baseline.entity;
2	
3	import com.llmquality.baseline.enums.AddressType;
4	import jakarta.persistence.*;
5	
6	import java.util.Objects;
7	
8	
9	@Entity
10	@Table(name = "addresses")
11	public class Address {
12	
13	    @Id
14	    @GeneratedValue(strategy = GenerationType.IDENTITY)
15	    private Long id;
16	
17	    @ManyToOne(fetch = FetchType.LAZY, optional = false)
18	    @JoinColumn(name = "user_id", nullable = false)
19	    private User user;
20	
21	    @Column(name = "street", nullable = false)
22	    private String street;
23	
24	    @Column(name = "house_number", nullable = false)
25	    private String houseNumber;
26	
27	    @Column(name = "postal_code", nullable = false)
28	    private String postalCode;
29	
30	    @Column(name = "city", nullable = false)
31	    private String city;
32	
33	    @Column(name = "country", nullable = false)
34	    private String country;
35	
36	    @Enumerated(EnumType.STRING)
37	    @Column(name = "address_type", nullable = false)
38	    private AddressType addressType;
39	
40	    public AddressType getAddressType() {
41	        return addressType;
42	    }
43	
44	    public void setAddressType(AddressType addressType) {
45	        this.addressType = addressType;
46	    }
47	
48	    public String getCountry() {
49	        return country;
50	    }
51	
52	    public void setCountry(String country) {
53	        this.country = country;
54	    }
55	
56	    public String getCity() {
57	        return city;
58	    }
59	
60	    public void setCity(String city) {
61	        this.city = city;
62	    }
63	
64	    public String getPostalCode() {
65	        return postalCode;
66	    }
67	
68	    public void setPostalCode(String postalCode) {
69	        this.postalCode = postalCode;
70	    }
71	
72	    public String getHouseNumber() {
73	        return houseNumber;
74	    }
75	
76	    public void setHouseNumber(String houseNumber) {
77	        this.houseNumber = houseNumber;
78	    }
79	
80	    public String getStreet() {
81	        return street;
82	    }
83	
84	    public void setStreet(String street) {
85	        this.street = street;
86	    }
87	
88	    public User getUser() {
89	        return user;
90	    }
91	
92	    public void setUser(User user) {
93	        this.user = user;
94	    }
95	
96	    public Long getId() {
97	        return id;
98	    }
99	
100	    public void setId(Long id) {
101	        this.id = id;
102	    }
103	
104	    @Override
105	    public boolean equals(Object o) {
106	        if (this == o) return true;
107	        if (!(o instanceof Address address)) return false;
108	        return Objects.equals(id, address.id);
109	    }
110	
111	    @Override
112	    public int hashCode() {
113	        return Objects.hash(id);
114	    }
115	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/entity/User.java =====

1	package com.llmquality.baseline.entity;
2	
3	import jakarta.persistence.*;
4	
5	import java.util.Objects;
6	
7	
8	@Entity
9	@Table(name = "users")
10	public class User {
11	
12	    @Id
13	    @GeneratedValue(strategy = GenerationType.IDENTITY)
14	    private Long id;
15	
16	    @Column(name = "username", nullable = false, unique = true)
17	    private String username;
18	
19	    @Column(name = "password", nullable = false, length = 60)
20	    private String password;
21	
22	    @Column(name = "email", nullable = false)
23	    private String email;
24	
25	    @Column(name = "isadmin", nullable = false)
26	    private boolean admin;
27	
28	    public boolean isAdmin() {
29	        return admin;
30	    }
31	
32	    public void setAdmin(boolean admin) {
33	        this.admin = admin;
34	    }
35	
36	    public String getEmail() {
37	        return email;
38	    }
39	
40	    public void setEmail(String email) {
41	        this.email = email;
42	    }
43	
44	    public String getPassword() {
45	        return password;
46	    }
47	
48	    public void setPassword(String password) {
49	        this.password = password;
50	    }
51	
52	    public String getUsername() {
53	        return username;
54	    }
55	
56	    public void setUsername(String username) {
57	        this.username = username;
58	    }
59	
60	    public Long getId() {
61	        return id;
62	    }
63	
64	    public void setId(Long id) {
65	        this.id = id;
66	    }
67	
68	    @Override
69	    public boolean equals(Object o) {
70	        if (this == o) return true;
71	        if (!(o instanceof User user)) return false;
72	        return Objects.equals(id, user.id);
73	    }
74	
75	    @Override
76	    public int hashCode() {
77	        return Objects.hash(id);
78	    }
79	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/enums/AddressType.java =====

1	package com.llmquality.baseline.enums;
2	
3	
4	/**
5	 * Enum representing the different types of addresses that a user can have.
6	 * <p>
7	 * This enum is used to categorize addresses into various types such as:
8	 * <ul>
9	 *     <li>{@link #PRIVATE} - A private address</li>
10	 *     <li>{@link #BUSINESS} - A business address</li>
11	 *     <li>{@link #SHIPPING} - A shipping address</li>
12	 *     <li>{@link #BILLING} - A billing address</li>
13	 * </ul>
14	 * </p>
15	 */
16	public enum AddressType {
17	    PRIVATE,
18	    BUSINESS,
19	    SHIPPING,
20	    BILLING
21	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/enums/Role.java =====

1	package com.llmquality.baseline.enums;
2	
3	
4	/**
5	 * Enum representing the roles available in the application.
6	 * Each role is associated with a string value used for
7	 * authorization and security purposes.
8	 *
9	 * <p>
10	 * Available roles:
11	 * <ul>
12	 *     <li>ADMIN - Represents an administrator with full access (ROLE_ADMIN)</li>
13	 *     <li>USER  - Represents a standard user with limited access (ROLE_USER)</li>
14	 * </ul>
15	 * </p>
16	 */
17	public enum Role {
18	    USER,
19	    ADMIN;
20	
21	    public static final String PREFIX = "ROLE_";
22	
23	    public String authority() {
24	        return PREFIX + name();
25	    }
26	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/BaselineProjectWebException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import java.io.Serial;
4	import java.io.Serializable;
5	
6	
7	/**
8	 * Abstract base class for custom exceptions used in the BaselineProject.
9	 * <p>
10	 * This class serves as the base for exceptions related to resource validation and error handling in the backend.
11	 * It holds information about the resource, field, and field value that caused the exception to be thrown.
12	 * Subclasses of this class should provide specific exception messages and behaviors.
13	 * </p>
14	 *
15	 * <p>Example:</p>
16	 * <pre>
17	 * throw new ResourceNotFoundException("not found", "User", "id", userId);
18	 * </pre>
19	 *
20	 * @see ResourceNotFoundException
21	 * @see ResourceAlreadyExistsException
22	 */
23	public abstract class BaselineProjectWebException extends RuntimeException {
24	
25	    @Serial
26	    private static final long serialVersionUID = -2713300573235999908L;
27	
28	    /**
29	     * Constructs a new BackendWebException with the specified message and details.
30	     * <p>
31	     * The message is formatted to include the resource name, message, field name, and field value.
32	     * </p>
33	     *
34	     * @param msg          the message to be included in the exception
35	     * @param resourceName the name of the resource
36	     * @param fieldName    the name of the field
37	     * @param fieldValue   the value of the field
38	     */
39	    protected BaselineProjectWebException(String msg, String resourceName, String fieldName, Serializable fieldValue) {
40	        super(String.format("%s %s %s : '%s'", resourceName, msg, fieldName, fieldValue));
41	    }
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/ResourceAlreadyExistsException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import org.springframework.http.HttpStatus;
4	import org.springframework.web.bind.annotation.ResponseStatus;
5	
6	import java.io.Serial;
7	import java.io.Serializable;
8	
9	
10	/**
11	 * Exception thrown when an attempt is made to create or modify a resource that already exists.
12	 * <p>
13	 * This exception is typically used when an attempt is made to create a resource (e.g., user, product) with
14	 * a unique field (e.g., email, username) that already exists in the system, violating the uniqueness constraint.
15	 * It returns a 409 Conflict HTTP status to indicate a conflict in the request due to existing data.
16	 * </p>
17	 *
18	 * <p>Example usage:</p>
19	 * <pre>
20	 * throw new ResourceAlreadyExistsException("User", "email", "test@example.com");
21	 * </pre>
22	 */
23	@ResponseStatus(value = HttpStatus.CONFLICT)
24	public class ResourceAlreadyExistsException extends BaselineProjectWebException {
25	
26	    @Serial
27	    private static final long serialVersionUID = 2978506968943653610L;
28	
29	    /**
30	     * Constructs a new ResourceAlreadyExistsException with a specified resource name, field name, and field value.
31	     * <p>
32	     * The exception message is formatted as "already exists" for the given resource and field.
33	     * </p>
34	     *
35	     * @param resourceName the name of the resource that the exception relates to (e.g., "User", "Product")
36	     * @param fieldName    the name of the field that caused the exception (e.g., "email", "username")
37	     * @param fieldValue   the value of the field that caused the exception (e.g., "test@example.com", "johndoe")
38	     */
39	    public ResourceAlreadyExistsException(String resourceName, String fieldName, Serializable fieldValue) {
40	        super("already exists", resourceName, fieldName, fieldValue);
41	    }
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/ResourceNotFoundException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import org.springframework.http.HttpStatus;
4	import org.springframework.web.bind.annotation.ResponseStatus;
5	
6	import java.io.Serial;
7	import java.io.Serializable;
8	
9	
10	/**
11	 * Exception thrown when a requested resource is not found in the system.
12	 * <p>
13	 * This exception is used to indicate that a resource, such as an entity or data, could not be found based on
14	 * the specified field and value. It returns a 404 Not Found HTTP status code to indicate that the requested
15	 * resource does not exist.
16	 * </p>
17	 *
18	 * <p>Example usage:</p>
19	 * <pre>
20	 * throw new ResourceNotFoundException("User", "id", 123);
21	 * </pre>
22	 */
23	@ResponseStatus(value = HttpStatus.NOT_FOUND)
24	public class ResourceNotFoundException extends BaselineProjectWebException {
25	
26	    @Serial
27	    private static final long serialVersionUID = 4703052950035630239L;
28	
29	    /**
30	     * Constructs a new ResourceNotFoundException with a specified resource name, field name, and field value.
31	     * <p>
32	     * The exception message is formatted as "not found with" for the given resource and field.
33	     * </p>
34	     *
35	     * @param resourceName the name of the resource that could not be found (e.g., "User", "Product")
36	     * @param fieldName    the name of the field that was used to search for the resource (e.g., "id", "username")
37	     * @param fieldValue   the value of the field that was used to search for the resource (e.g., 123, "john_doe")
38	     */
39	    public ResourceNotFoundException(String resourceName, String fieldName, Serializable fieldValue) {
40	        super("not found with", resourceName, fieldName, fieldValue);
41	    }
42	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/UnauthorizedException.java =====

1	package com.llmquality.baseline.exception;
2	
3	import org.springframework.http.HttpStatus;
4	import org.springframework.web.bind.annotation.ResponseStatus;
5	
6	import java.io.Serial;
7	import java.io.Serializable;
8	
9	
10	/**
11	 * Thrown when authentication fails due to invalid username or password.
12	 * <p>
13	 * This exception is annotated with {@code @ResponseStatus(HttpStatus.UNAUTHORIZED)} and therefore
14	 * automatically returns HTTP 401 Unauthorized without any additional configuration.
15	 * </p>
16	 * <p>
17	 * It is the recommended way in modern Spring Boot 3+ REST APIs to handle failed login attempts.
18	 * Using this instead of returning {@code success: false} with 200 OK prevents information leakage
19	 * (username enumeration) and follows proper HTTP semantics.
20	 * </p>
21	 * <p>
22	 * Example usage:
23	 * <pre>
24	 * throw new UnauthorizedException("User", "username", username);
25	 * </pre>
26	 * </p>
27	 */
28	@ResponseStatus(value = HttpStatus.UNAUTHORIZED)
29	public class UnauthorizedException extends BaselineProjectWebException {
30	
31	    @Serial
32	    private static final long serialVersionUID = -4368911695070591266L;
33	
34	    /**
35	     * Constructs a new UnauthorizedException with details about the authentication failure.
36	     * <p>
37	     * The exception message is formatted as "access unauthorized for {resourceName} {fieldName} : '{fieldValue}'".
38	     * </p>
39	     *
40	     * @param resourceName the name of the resource that required authentication (e.g., "User")
41	     * @param fieldName    the name of the field that caused the failure (e.g., "username" or "credentials")
42	     * @param fieldValue   the value of the field that was invalid (e.g., the provided username)
43	     */
44	    public UnauthorizedException(String resourceName, String fieldName, Serializable fieldValue) {
45	        super("access unauthorized for", resourceName, fieldName, fieldValue);
46	    }
47	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/exception/handler/GlobalExceptionHandler.java =====

1	package com.llmquality.baseline.exception.handler;
2	
3	import com.llmquality.baseline.exception.BaselineProjectWebException;
4	import org.springframework.http.HttpStatus;
5	import org.springframework.http.ResponseEntity;
6	import org.springframework.http.converter.HttpMessageNotReadableException;
7	import org.springframework.web.bind.MethodArgumentNotValidException;
8	import org.springframework.web.bind.annotation.ExceptionHandler;
9	import org.springframework.web.bind.annotation.ResponseStatus;
10	import org.springframework.web.bind.annotation.RestControllerAdvice;
11	
12	import java.util.List;
13	
14	
15	/**
16	 * Global exception handler that converts domain-specific and validation-related
17	 * exceptions into clean and consistent API error responses.
18	 */
19	@RestControllerAdvice
20	public class GlobalExceptionHandler {
21	
22	    @ExceptionHandler(BaselineProjectWebException.class)
23	    public ResponseEntity<ErrorResponse> handleBaselineException(final BaselineProjectWebException ex) {
24	        final ResponseStatus annotation = ex.getClass().getAnnotation(ResponseStatus.class);
25	        final HttpStatus httpStatus = (annotation != null) ? annotation.value() : HttpStatus.INTERNAL_SERVER_ERROR;
26	        return ResponseEntity.status(httpStatus)
27	                .body(new ErrorResponse(
28	                        httpStatus.value(),
29	                        ex.getMessage()
30	                ));
31	    }
32	
33	    @ExceptionHandler(MethodArgumentNotValidException.class)
34	    public ResponseEntity<ValidationErrorResponse> handleValidation(final MethodArgumentNotValidException ex) {
35	        final List<ValidationErrorResponse.FieldError> errors =
36	                ex.getBindingResult().getFieldErrors()
37	                        .stream()
38	                        .map(err -> new ValidationErrorResponse.FieldError(
39	                                err.getField(),
40	                                err.getRejectedValue(),
41	                                err.getDefaultMessage()
42	                        ))
43	                        .toList();
44	        return ResponseEntity.badRequest().body(new ValidationErrorResponse(400, "Validation failed", errors));
45	    }
46	
47	    @ExceptionHandler(HttpMessageNotReadableException.class)
48	    public ResponseEntity<ErrorResponse> handleMalformedJson(final HttpMessageNotReadableException ex) {
49	        return ResponseEntity.badRequest().body(new ErrorResponse(HttpStatus.BAD_REQUEST.value(),
50	                "Malformed JSON request: " + ex.getMostSpecificCause().getMessage()));
51	    }
52	
53	
54	    // Response Records
55	    public record ErrorResponse(int status, String message) {
56	    }
57	
58	    public record ValidationErrorResponse(int status, String message, List<FieldError> errors) {
59	        public record FieldError(String field, Object rejectedValue, String message) {
60	        }
61	    }
62	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/logging/LoggingConfig.java =====

1	package com.llmquality.baseline.logging;
2	
3	import ch.qos.logback.classic.AsyncAppender;
4	import ch.qos.logback.classic.Level;
5	import ch.qos.logback.classic.Logger;
6	import ch.qos.logback.classic.LoggerContext;
7	import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
8	import ch.qos.logback.classic.spi.ILoggingEvent;
9	import ch.qos.logback.core.ConsoleAppender;
10	import ch.qos.logback.core.rolling.RollingFileAppender;
11	import ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy;
12	import ch.qos.logback.core.util.FileSize;
13	import jakarta.annotation.PostConstruct;
14	import jakarta.annotation.PreDestroy;
15	import org.slf4j.LoggerFactory;
16	import org.springframework.beans.factory.annotation.Value;
17	import org.springframework.context.annotation.Configuration;
18	import org.springframework.core.env.Environment;
19	
20	import java.nio.file.Files;
21	import java.nio.file.Path;
22	import java.nio.file.Paths;
23	import java.util.Map;
24	import java.util.Objects;
25	import java.util.TimeZone;
26	
27	
28	/**
29	 * Configures programmatic Logback logging for the application.
30	 * <p>
31	 * Features:
32	 * <ul>
33	 *     <li>Profile-aware log levels (dev = DEBUG, others = INFO by default)</li>
34	 *     <li>Asynchronous file logging with size/time-based rolling</li>
35	 * <li>Optional synchronous console logging</li>
36	 *     <li>Fully configurable via Spring Boot properties</li>
37	 * </ul>
38	 * This replaces XML configuration and initializes Logback at startup.
39	 */
40	@Configuration
41	public class LoggingConfig {
42	
43	    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(LoggingConfig.class);
44	
45	    private static final String DEFAULT_LOG_DIR = "logs";
46	    private static final String DEFAULT_LOG_PATTERN = "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n";
47	    private static final String DEFAULT_ROLLING_PATTERN = "application-%d{yyyy-MM-dd}.%i.log";
48	    private static final String DEFAULT_MAX_FILE_SIZE = "10MB";
49	    private static final String DEFAULT_TOTAL_SIZE_CAP = "100MB";
50	
51	    @Value("${logging.file.path:/home/dbe/projects/llm-code-quality-experiment/baseline_project/logs}")
52	    private String logDirectoryPath;
53	
54	    @Value("${logging.file.name:application:errors.log}")
55	    private String logFileName;
56	
57	    @Value("${logging.level.root:#{null}}")
58	    private String rootLogLevel;
59	
60	    @Value("#{${logging.level:{:}}}")
61	    private Map<String, String> loggerLevels;
62	
63	    @Value("${logging.console.enabled:#{null}}")
64	    private Boolean consoleEnabled;
65	
66	    @Value("${logging.pattern:" + DEFAULT_LOG_PATTERN + "}")
67	    private String logPattern;
68	
69	    @Value("${logging.rolling.fileNamePattern:" + DEFAULT_ROLLING_PATTERN + "}")
70	    private String rollingFileNamePattern;
71	
72	    @Value("${logging.rolling.maxFileSize:10MB}")
73	    private String maxFileSizeStr;
74	
75	    @Value("${logging.rolling.maxHistory:30}")
76	    private int maxHistory;
77	
78	    @Value("${logging.rolling.totalSizeCap:100MB}")
79	    private String totalSizeCapStr;
80	
81	    private final Environment environment;
82	    private LoggerContext loggerContext;
83	    private volatile boolean initialized = false;
84	
85	    public LoggingConfig(Environment environment) {
86	        this.environment = environment;
87	    }
88	
89	    @PostConstruct
90	    public synchronized void initializeLogging() {
91	        if (initialized) return;
92	        initialized = true;
93	
94	        try {
95	            loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
96	            System.setProperty("user.timezone", "UTC");
97	            TimeZone.setDefault(TimeZone.getTimeZone("UTC"));
98	
99	            Path logDir = createLogDirectory(logDirectoryPath);
100	
101	            String[] activeProfiles = environment.getActiveProfiles();
102	            String profile = activeProfiles.length > 0 ? activeProfiles[0] : "dev";
103	
104	            Level level;
105	            boolean console;
106	            if (rootLogLevel != null) {
107	                level = Level.toLevel(rootLogLevel, Level.INFO);
108	            } else if ("dev".equals(profile)) {
109	                level = Level.DEBUG;
110	            } else {
111	                level = Level.INFO;
112	            }
113	
114	            console = Objects.requireNonNullElseGet(consoleEnabled, () -> "dev".equals(profile));
115	
116	            RollingFileAppender<ILoggingEvent> rollingFileAppender = createRollingFileAppender(logDir);
117	
118	            AsyncAppender asyncFileAppender = new AsyncAppender();
119	            asyncFileAppender.setContext(loggerContext);
120	            asyncFileAppender.setName("ASYNC_FILE");
121	            asyncFileAppender.addAppender(rollingFileAppender);
122	            asyncFileAppender.start();
123	
124	            ConsoleAppender<ILoggingEvent> consoleAppender = null;
125	            if (console) {
126	                consoleAppender = createConsoleAppender();
127	            }
128	
129	            configureRootLogger(asyncFileAppender, consoleAppender, level);
130	
131	            configurePackageSpecificLoggers();
132	
133	            LOG.info("Logging initialized successfully. Profile: {}. Log directory: {}", profile, logDir.toAbsolutePath());
134	
135	        } catch (Exception e) {
136	            LOG.error("Failed to initialize logging", e);
137	        }
138	    }
139	
140	    @PreDestroy
141	    public void shutdownLogging() {
142	        if (loggerContext != null) {
143	            loggerContext.stop();
144	        }
145	    }
146	
147	    private Path createLogDirectory(String path) {
148	        Objects.requireNonNull(path, "Log directory path must not be null");
149	        try {
150	            Path logPath = Paths.get(path);
151	            if (!Files.exists(logPath)) Files.createDirectories(logPath);
152	            return logPath;
153	        } catch (Exception e) {
154	            LOG.error("Failed to create log directory '{}'. Falling back to '{}'.", path, DEFAULT_LOG_DIR, e);
155	            try {
156	                Path fallback = Paths.get(DEFAULT_LOG_DIR);
157	                Files.createDirectories(fallback);
158	                return fallback;
159	            } catch (Exception ex) {
160	                LOG.error("Fallback directory '{}' failed. Using current dir.", DEFAULT_LOG_DIR, ex);
161	                return Paths.get(".");
162	            }
163	        }
164	    }
165	
166	    private PatternLayoutEncoder createEncoder(String pattern) {
167	        if (pattern == null || pattern.isEmpty()) {
168	            pattern = DEFAULT_LOG_PATTERN;
169	        }
170	        PatternLayoutEncoder encoder = new PatternLayoutEncoder();
171	        encoder.setContext(loggerContext);
172	        encoder.setPattern(pattern);
173	        encoder.start();
174	        return encoder;
175	    }
176	
177	    private RollingFileAppender<ILoggingEvent> createRollingFileAppender(Path logDir) {
178	        PatternLayoutEncoder encoder = createEncoder(logPattern);
179	
180	        RollingFileAppender<ILoggingEvent> rollingFileAppender = new RollingFileAppender<>();
181	        rollingFileAppender.setContext(loggerContext);
182	        rollingFileAppender.setName("ROLLING_FILE");
183	        rollingFileAppender.setFile(logDir.resolve(logFileName).toString());
184	        rollingFileAppender.setEncoder(encoder);
185	
186	        SizeAndTimeBasedRollingPolicy<ILoggingEvent> rollingPolicy = new SizeAndTimeBasedRollingPolicy<>();
187	        rollingPolicy.setContext(loggerContext);
188	        rollingPolicy.setParent(rollingFileAppender);
189	
190	        if (rollingFileNamePattern == null || rollingFileNamePattern.isEmpty()) {
191	            rollingFileNamePattern = DEFAULT_ROLLING_PATTERN;
192	        }
193	        rollingPolicy.setFileNamePattern(logDir.resolve(rollingFileNamePattern).toString());
194	
195	        FileSize maxFileSize;
196	        try {
197	            maxFileSize = FileSize.valueOf(maxFileSizeStr);
198	        } catch (Exception e) {
199	            LOG.warn("Invalid maxFileSize '{}', using default {}", maxFileSizeStr, DEFAULT_MAX_FILE_SIZE);
200	            maxFileSize = FileSize.valueOf(DEFAULT_MAX_FILE_SIZE);
201	        }
202	        rollingPolicy.setMaxFileSize(maxFileSize);
203	
204	        rollingPolicy.setMaxHistory(maxHistory);
205	
206	        FileSize totalSizeCap;
207	        try {
208	            totalSizeCap = FileSize.valueOf(totalSizeCapStr);
209	        } catch (Exception e) {
210	            LOG.warn("Invalid totalSizeCap '{}', using default {}", totalSizeCapStr, DEFAULT_TOTAL_SIZE_CAP);
211	            totalSizeCap = FileSize.valueOf(DEFAULT_TOTAL_SIZE_CAP);
212	        }
213	        rollingPolicy.setTotalSizeCap(totalSizeCap);
214	
215	        rollingPolicy.start();
216	        rollingFileAppender.setRollingPolicy(rollingPolicy);
217	        rollingFileAppender.start();
218	
219	        return rollingFileAppender;
220	    }
221	
222	
223	    private ConsoleAppender<ILoggingEvent> createConsoleAppender() {
224	        PatternLayoutEncoder encoder = createEncoder(logPattern);
225	        ConsoleAppender<ILoggingEvent> consoleAppender = new ConsoleAppender<>();
226	        consoleAppender.setContext(loggerContext);
227	        consoleAppender.setName("CONSOLE");
228	        consoleAppender.setEncoder(encoder);
229	        consoleAppender.start();
230	        return consoleAppender;
231	    }
232	
233	    private void configureRootLogger(AsyncAppender asyncFileAppender,
234	                                     ConsoleAppender<ILoggingEvent> consoleAppender,
235	                                     Level level) {
236	
237	        Logger rootLogger = loggerContext.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);
238	        rootLogger.detachAndStopAllAppenders();
239	
240	        rootLogger.addAppender(asyncFileAppender);
241	
242	        if (consoleAppender != null) {
243	            rootLogger.addAppender(consoleAppender);
244	        }
245	
246	        rootLogger.setLevel(level);
247	        rootLogger.setAdditive(false);
248	    }
249	
250	    private void configurePackageSpecificLoggers() {
251	        for (Map.Entry<String, String> entry : loggerLevels.entrySet()) {
252	            String loggerName = entry.getKey();
253	            if ("root".equalsIgnoreCase(loggerName)) {
254	                continue; // Root is already configured
255	            }
256	            Level lvl = Level.toLevel(entry.getValue(), Level.INFO);
257	            loggerContext.getLogger(loggerName).setLevel(lvl);
258	        }
259	    }
260	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/mapper/AddressMapper.java =====

1	package com.llmquality.baseline.mapper;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.entity.Address;
6	import com.llmquality.baseline.entity.User;
7	import org.mapstruct.*;
8	
9	
10	/**
11	 * Mapper interface for converting between {@link Address} entity and Address DTOs.
12	 * <p>
13	 * This interface defines the mappings to transform the {@link AddressRequest} to an {@link Address} entity,
14	 * and vice versa, as well as handling address updates from {@link AddressRequest}.
15	 * </p>
16	 */
17	@Mapper(componentModel = "spring")
18	public interface AddressMapper {
19	
20	    /**
21	     * Maps an {@link AddressRequest} DTO and a {@link User} entity to an {@link Address} entity.
22	     * The {@code id} field is ignored because it is managed by the database.
23	     * The user is mapped as a reference in the entity.
24	     *
25	     * @param addressRequest the {@link AddressRequest} DTO to map
26	     * @param user           the {@link User} entity that the address is associated with
27	     * @return the mapped {@link Address} entity
28	     */
29	    @Mapping(target = "id", ignore = true)
30	    @Mapping(target = "user", source = "user")
31	    Address toAddressEntity(AddressRequest addressRequest, User user);
32	
33	    /**
34	     * Maps an {@link Address} entity to an {@link AddressResponse} DTO.
35	     * The user's ID is mapped from the {@link User} entity to the {@link AddressResponse}.
36	     *
37	     * @param address the {@link Address} entity to map
38	     * @return the mapped {@link AddressResponse} DTO
39	     */
40	    @Mapping(target = "userId", source = "user.id")
41	    AddressResponse toAddressResponse(Address address);
42	
43	    /**
44	     * Updates an {@link Address} entity using values from the provided {@link AddressRequest} DTO.
45	     * <p>
46	     * The {@code id} and {@code user} fields are ignored since they should not be modified.
47	     * Only non-null values from the DTO will be mapped onto the existing entity.
48	     * </p>
49	     *
50	     * @param addressRequest the {@link AddressRequest} DTO containing the updated data
51	     * @param address        the {@link Address} entity to update
52	     * @return the updated {@link Address} entity
53	     */
54	    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
55	    @Mapping(target = "id", ignore = true)
56	    @Mapping(target = "user", ignore = true)
57	    Address updateAddressEntityFromAddressRequest(AddressRequest addressRequest, @MappingTarget Address address);
58	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/mapper/UserMapper.java =====

1	package com.llmquality.baseline.mapper;
2	
3	import com.llmquality.baseline.dto.UserRequest;
4	import com.llmquality.baseline.dto.UserResponse;
5	import com.llmquality.baseline.entity.User;
6	import org.mapstruct.*;
7	import org.springframework.security.crypto.password.PasswordEncoder;
8	
9	
10	/**
11	 * Mapper interface for converting between database entity {@link User} and User DTOs.
12	 */
13	@Mapper(componentModel = "spring")
14	public interface UserMapper {
15	
16	    /**
17	     * Maps a {@link UserRequest} to a {@link User} entity.
18	     * The {@code id} is ignored since it is managed by JPA/database.
19	     * The password is hashed using the provided {@link PasswordEncoder}.
20	     *
21	     * @param dto             the DTO to map
22	     * @param passwordEncoder the password encoder to hash the password
23	     * @return the mapped User entity with hashed password
24	     */
25	    @Mapping(target = "id", ignore = true)
26	    @Mapping(target = "password", expression = "java(passwordEncoder.encode(dto.password()))")
27	    User toUserEntity(UserRequest dto, @Context PasswordEncoder passwordEncoder);
28	
29	    /**
30	     * Maps a {@link User} entity to a {@link UserResponse}.
31	     *
32	     * @param user the entity to map
33	     * @return the DTO representing the user without sensitive data
34	     */
35	    UserResponse toUserResponse(User user);
36	
37	    /**
38	     * Updates the fields of the given {@link User} entity using values from the provided {@link UserRequest} DTO.
39	     * <p>
40	     * The method will map the following fields:
41	     * <ul>
42	     *     <li> {@code id} is ignored (not mapped) </li>
43	     *     <li> {@code username}, {@code email}, {@code password}, and {@code admin} are mapped from the DTO to the entity,
44	     *          with any {@code null} values being ignored. </li>
45	     * </ul>
46	     * The password is hashed using the provided {@link PasswordEncoder}.
47	     *
48	     * @param dto             the {@link UserRequest} DTO containing the data to update the entity.
49	     * @param entity          the {@link User} entity to be updated.
50	     * @param passwordEncoder the password encoder to hash the password
51	     * @return the mapped User entity with hashed password(if changed)
52	     */
53	    @BeanMapping(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
54	    @Mapping(target = "id", ignore = true)
55	    @Mapping(target = "password", expression = "java(dto.password() != null ? passwordEncoder.encode(passwordEncoder.encode(dto.password())) : entity.getPassword())")
56	    User updateUserEntityFromUserRequest(UserRequest dto, @MappingTarget User entity, @Context PasswordEncoder passwordEncoder);
57	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/repository/AddressRepository.java =====

1	package com.llmquality.baseline.repository;
2	
3	import com.llmquality.baseline.entity.Address;
4	import org.springframework.data.domain.Page;
5	import org.springframework.data.domain.Pageable;
6	import org.springframework.data.jpa.repository.JpaRepository;
7	import org.springframework.stereotype.Repository;
8	
9	
10	@Repository
11	public interface AddressRepository extends JpaRepository<Address, Long> {
12	
13	    Page<Address> findAllByUserId(Long userId, Pageable pageable);
14	
15	    boolean existsByIdAndUserId(Long id, Long userId);
16	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/repository/UserRepository.java =====

1	package com.llmquality.baseline.repository;
2	
3	import com.llmquality.baseline.entity.User;
4	import org.springframework.data.jpa.repository.JpaRepository;
5	import org.springframework.stereotype.Repository;
6	
7	import java.util.Optional;
8	
9	
10	@Repository
11	public interface UserRepository extends JpaRepository<User, Long> {
12	
13	    Optional<User> findByUsername(String username);
14	
15	    boolean existsByUsername(String username);
16	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/security/SecurityConfig.java =====

1	package com.llmquality.baseline.security;
2	
3	import com.nimbusds.jose.jwk.source.ImmutableSecret;
4	import org.springframework.beans.factory.annotation.Value;
5	import org.springframework.context.annotation.Bean;
6	import org.springframework.context.annotation.Configuration;
7	import org.springframework.http.HttpMethod;
8	import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
9	import org.springframework.security.config.annotation.web.builders.HttpSecurity;
10	import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
11	import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
12	import org.springframework.security.config.http.SessionCreationPolicy;
13	import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
14	import org.springframework.security.crypto.password.PasswordEncoder;
15	import org.springframework.security.oauth2.jwt.JwtDecoder;
16	import org.springframework.security.oauth2.jwt.JwtEncoder;
17	import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;
18	import org.springframework.security.oauth2.jwt.NimbusJwtEncoder;
19	import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
20	import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
21	import org.springframework.security.web.SecurityFilterChain;
22	
23	import javax.crypto.SecretKey;
24	import javax.crypto.spec.SecretKeySpec;
25	import java.util.Base64;
26	
27	
28	/**
29	 * Configuration class for application security.
30	 * <p>
31	 * This class sets up the security filter chain, password encoding, and JWT encoding/decoding
32	 * for the application using Spring Security. It configures stateless session management,
33	 * disables CSRF protection for simplicity in a REST API context, and sets access rules
34	 * for public and authenticated endpoints.
35	 * </p>
36	 * <p>
37	 * The JWT secret key is injected from application properties and used for both encoding
38	 * and decoding JWT tokens. A {@link PasswordEncoder} bean is also provided for hashing
39	 * user passwords securely.
40	 * </p>
41	 * <p>
42	 * Public endpoints include login and user registration, while all other requests require
43	 * authentication. OAuth2 resource server support is enabled for JWT-based authentication.
44	 * </p>
45	 */
46	@Configuration
47	@EnableWebSecurity
48	@EnableMethodSecurity
49	public class SecurityConfig {
50	
51	    @Value("${jwt.secret}")
52	    private String jwtSecret;
53	
54	    @Value("${api.base-path}")
55	    private String apiBasePath;
56	
57	    private static final String JWT_ALGORITHM = "HmacSHA256";
58	
59	    @Bean
60	    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
61	        http
62	                .csrf(AbstractHttpConfigurer::disable)
63	                .authorizeHttpRequests(auth -> auth
64	                        .requestMatchers("/error", "/error/**").permitAll()
65	                        .requestMatchers(apiBasePath + "/users/login").permitAll()
66	                        .requestMatchers(HttpMethod.POST, apiBasePath + "/users").permitAll()
67	                        .anyRequest().authenticated()
68	                )
69	                .oauth2ResourceServer(oauth2 -> oauth2
70	                        .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter())
71	                        )
72	                )
73	                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
74	
75	        return http.build();
76	    }
77	
78	    @Bean
79	    public JwtAuthenticationConverter jwtAuthenticationConverter() {
80	        JwtGrantedAuthoritiesConverter authoritiesConverter = new JwtGrantedAuthoritiesConverter();
81	        authoritiesConverter.setAuthorityPrefix("ROLE_");
82	        authoritiesConverter.setAuthoritiesClaimName("scope");
83	
84	        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
85	        converter.setJwtGrantedAuthoritiesConverter(authoritiesConverter);
86	        converter.setPrincipalClaimName("sub");
87	        return converter;
88	    }
89	
90	    @Bean
91	    public PasswordEncoder passwordEncoder() {
92	        return new BCryptPasswordEncoder();
93	    }
94	
95	    @Bean
96	    public JwtEncoder jwtEncoder() {
97	        SecretKey key = createSecretKey(jwtSecret);
98	        return new NimbusJwtEncoder(new ImmutableSecret<>(key));
99	    }
100	
101	    @Bean
102	    public JwtDecoder jwtDecoder() {
103	        SecretKey key = createSecretKey(jwtSecret);
104	        return NimbusJwtDecoder.withSecretKey(key).build();
105	    }
106	
107	    private SecretKey createSecretKey(String base64Secret) {
108	        byte[] secretBytes = Base64.getDecoder().decode(base64Secret);
109	        return new SecretKeySpec(secretBytes, JWT_ALGORITHM);
110	    }
111	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/security/SecurityExpressions.java =====

1	package com.llmquality.baseline.security;
2	
3	import com.llmquality.baseline.enums.Role;
4	import org.springframework.security.core.Authentication;
5	import org.springframework.stereotype.Component;
6	
7	
8	/**
9	 * Custom Spring Security expressions for method security.
10	 * <p>
11	 * Registered as Spring bean with name "sec" → usable in @PreAuthorize as @sec.xxx()
12	 * This is the official and recommended way to keep @PreAuthorize expressions clean and testable.
13	 * </p>
14	 */
15	@Component("sec")
16	public class SecurityExpressions {
17	
18	    public boolean isOwner(Long resourceOwnerId, Authentication auth) {
19	        return resourceOwnerId != null
20	                && auth != null
21	                && auth.getName() != null
22	                && resourceOwnerId.toString().equals(auth.getName());
23	    }
24	
25	    public boolean canSetAdminFlag(Boolean newValue, Authentication auth) {
26	        return newValue == null || !newValue || isAdmin(auth);
27	    }
28	
29	    public boolean isAdmin(Authentication auth) {
30	        if (auth == null || auth.getAuthorities() == null) return false;
31	        return auth.getAuthorities().stream()
32	                .anyMatch(granted -> Role.ADMIN.authority().equals(granted.getAuthority()));
33	    }
34	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/AddressServiceImpl.java =====

1	package com.llmquality.baseline.service;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.dto.PagedResponse;
6	import com.llmquality.baseline.entity.Address;
7	import com.llmquality.baseline.entity.User;
8	import com.llmquality.baseline.exception.ResourceNotFoundException;
9	import com.llmquality.baseline.mapper.AddressMapper;
10	import com.llmquality.baseline.repository.AddressRepository;
11	import com.llmquality.baseline.repository.UserRepository;
12	import com.llmquality.baseline.service.interfaces.AddressService;
13	import org.slf4j.LoggerFactory;
14	import org.springframework.beans.factory.annotation.Autowired;
15	import org.springframework.data.domain.Page;
16	import org.springframework.data.domain.Pageable;
17	import org.springframework.stereotype.Service;
18	import org.springframework.transaction.annotation.Transactional;
19	
20	import java.util.Objects;
21	
22	
23	@Service
24	@Transactional(readOnly = true)
25	public class AddressServiceImpl implements AddressService {
26	
27	    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(AddressServiceImpl.class);
28	
29	    private static final String USER = "User";
30	
31	    private static final String ADDRESS = "Address";
32	
33	    private final AddressRepository addressRepository;
34	
35	    private final UserRepository userRepository;
36	
37	    private final AddressMapper addressMapper;
38	
39	
40	    @Autowired
41	    public AddressServiceImpl(AddressRepository addressRepository, UserRepository userRepository, AddressMapper addressMapper) {
42	        this.addressRepository = addressRepository;
43	        this.userRepository = userRepository;
44	        this.addressMapper = addressMapper;
45	    }
46	
47	    @Override
48	    public PagedResponse<AddressResponse> listAll(final Long userId, final Pageable pageable) {
49	        LOG.debug("--> listAll, page={}, size={}", pageable.getPageNumber(), pageable.getPageSize());
50	
51	        final User existingUserEntity = userRepository.findById(userId)
52	                .orElseThrow(() -> {
53	                    LOG.error("<-- listAll, User with ID {} not found", userId);
54	                    return new ResourceNotFoundException(USER, "id", userId);
55	                });
56	
57	        final Page<AddressResponse> page = addressRepository
58	                .findAllByUserId(existingUserEntity.getId(), pageable)
59	                .map(addressMapper::toAddressResponse);
60	        LOG.debug("<-- listAll, total elements={}, total pages={}", page.getTotalElements(), page.getTotalPages());
61	        return PagedResponse.fromPage(page);
62	    }
63	
64	    @Override
65	    public AddressResponse getById(Long userId, Long addressId) {
66	        LOG.debug("--> getById, userId: {} and addressId: {}", userId, addressId);
67	        final Address existingAddressEntity = addressRepository.findById(addressId).get();
68	
69	        enforceAddressOwnership(existingAddressEntity, userId);
70	
71	        final AddressResponse addressResponse = addressMapper.toAddressResponse(existingAddressEntity);
72	        LOG.debug("<-- getById, userId: {} and addressId: {}", userId, addressResponse.id());
73	        return addressResponse;
74	    }
75	
76	    @Transactional
77	    @Override
78	    public AddressResponse save(final Long userId, final AddressRequest addressRequest) {
79	        LOG.debug("--> save, address for user with userId: {}", userId);
80	        final User existingUserEntity = userRepository.findById(userId)
81	                .orElseThrow(() -> {
82	                    LOG.error("<-- getById, User with userId {} not found", userId);
83	                    return new ResourceNotFoundException(USER, "id", userId);
84	                });
85	
86	        final Address addressEntity = addressMapper.toAddressEntity(addressRequest, existingUserEntity);
87	        final AddressResponse addressResponse = addressMapper.toAddressResponse(addressEntity);
88	        LOG.debug("<-- save, address saved with id: {}", addressEntity.getId());
89	        return addressResponse;
90	    }
91	
92	    @Transactional
93	    @Override
94	    public AddressResponse update(final Long userId, final Long addressId, final AddressRequest addressRequest) {
95	        LOG.debug("--> update, address with addressId: {} by userId: {}", addressId, userId);
96	        final Address existingAddressEntity = addressRepository.findById(addressId)
97	                .orElseThrow(() -> {
98	                    LOG.error("<-- update, Address with ID {} not found", addressId);
99	                    return new ResourceNotFoundException(ADDRESS, "id", addressId);
100	                });
101	
102	        enforceAddressOwnership(existingAddressEntity, userId);
103	
104	        // Partial update via updateAddressEntityFromAddressRequest
105	        final Address updatedAddressEntity = addressMapper.updateAddressEntityFromAddressRequest(addressRequest, existingAddressEntity);
106	        final Address saveAddressEntity = addressRepository.save(updatedAddressEntity);
107	        final AddressResponse addressResponse = addressMapper.toAddressResponse(saveAddressEntity);
108	        LOG.debug("<-- update, address with addressId: {} by userId: {}", addressResponse.id(), addressResponse.userId());
109	        return addressResponse;
110	    }
111	
112	    @Transactional
113	    @Override
114	    public void delete(final Long userId, final Long addressId) {
115	        LOG.debug("--> delete, addressId: {}", addressId);
116	        final Address existingAddressEntity = addressRepository.findById(addressId)
117	                .orElseThrow(() -> {
118	                    LOG.error("<-- delete, Address with ID {} not found", addressId);
119	                    return new ResourceNotFoundException(ADDRESS, "id", addressId);
120	                });
121	
122	        enforceAddressOwnership(existingAddressEntity, userId);
123	
124	        addressRepository.delete(existingAddressEntity);
125	        LOG.debug("<-- delete, address with id {} deleted", existingAddressEntity.getId());
126	    }
127	
128	    /**
129	     * Enforces that the given address belongs to the requested user.
130	     * <p>
131	     * Throws {@link ResourceNotFoundException} (404) on mismatch to prevent information disclosure.
132	     * Must be called after loading the address and after coarse-grained {@code @PreAuthorize} check.
133	     * </p>
134	     *
135	     * @param address         the loaded address entity
136	     * @param requestedUserId the userId from the request path
137	     * @throws ResourceNotFoundException if address does not belong to requestedUserId
138	     */
139	    private void enforceAddressOwnership(Address address, Long requestedUserId) {
140	        LOG.debug("--> enforceAddressOwnership");
141	        final Long ownerId = (address.getUser() != null) ? address.getUser().getId() : null;
142	
143	        if (!Objects.equals(ownerId, requestedUserId)) {
144	            LOG.warn("<-- enforceAddressOwnership, Access denied: User {} tried to access address {} (ownerId={})",
145	                    requestedUserId, address.getId(), ownerId);
146	            throw new ResourceNotFoundException(ADDRESS, "id", address.getId());
147	        }
148	        LOG.debug("<-- enforceAddressOwnership, Ownership confirmed");
149	    }
150	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/UserServiceImpl.java =====

1	package com.llmquality.baseline.service;
2	
3	import com.llmquality.baseline.dto.*;
4	import com.llmquality.baseline.entity.User;
5	import com.llmquality.baseline.enums.Role;
6	import com.llmquality.baseline.exception.ResourceAlreadyExistsException;
7	import com.llmquality.baseline.exception.ResourceNotFoundException;
8	import com.llmquality.baseline.exception.UnauthorizedException;
9	import com.llmquality.baseline.mapper.UserMapper;
10	import com.llmquality.baseline.repository.UserRepository;
11	import com.llmquality.baseline.service.interfaces.UserService;
12	import jakarta.persistence.EntityManager;
13	import org.slf4j.LoggerFactory;
14	import org.springframework.beans.factory.annotation.Autowired;
15	import org.springframework.beans.factory.annotation.Value;
16	import org.springframework.data.domain.Page;
17	import org.springframework.data.domain.PageImpl;
18	import org.springframework.data.domain.Pageable;
19	import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
20	import org.springframework.security.oauth2.jose.jws.MacAlgorithm;
21	import org.springframework.security.oauth2.jwt.JwsHeader;
22	import org.springframework.security.oauth2.jwt.JwtClaimsSet;
23	import org.springframework.security.oauth2.jwt.JwtEncoder;
24	import org.springframework.security.oauth2.jwt.JwtEncoderParameters;
25	import org.springframework.stereotype.Service;
26	import org.springframework.security.crypto.password.PasswordEncoder;
27	import org.springframework.transaction.annotation.Transactional;
28	
29	import java.time.Instant;
30	import java.time.temporal.ChronoUnit;
31	import java.util.List;
32	import java.util.Objects;
33	
34	
35	@Service
36	@Transactional(readOnly = true)
37	public class UserServiceImpl implements UserService {
38	
39	    private static final org.slf4j.Logger LOG = LoggerFactory.getLogger(UserServiceImpl.class);
40	
41	    private static final String USER = "User";
42	
43	    // Prevent timing attack (username enumeration) by always performing password comparison
44	    private static final String DUMMY_HASH = "$2a$10$dummydummydummydummydummydummydummydummydummydummy";
45	
46	    private final UserRepository userRepository;
47	
48	    private final PasswordEncoder passwordEncoder;
49	
50	    private final UserMapper userMapper;
51	
52	    private final EntityManager entityManager;
53	
54	    private final JwtEncoder jwtEncoder;
55	
56	    @Value("${jwt.issuer:self}")
57	    private String jwtIssuer;
58	
59	    @Value("${jwt.expiration-hours:6}")
60	    private long jwtExpirationHours;
61	
62	    @Autowired
63	    public UserServiceImpl(UserRepository userRepository, PasswordEncoder passwordEncoder, UserMapper userMapper, EntityManager entityManager, JwtEncoder jwtEncoder) {
64	        this.userRepository = userRepository;
65	        this.passwordEncoder = passwordEncoder;
66	        this.userMapper = userMapper;
67	        this.entityManager = entityManager;
68	        this.jwtEncoder = jwtEncoder;
69	    }
70	
71	    @Override
72	    public PagedResponse<UserResponse> listAll(Pageable pageable) {
73	        LOG.debug("--> listAll, page={}, size={}", pageable.getPageNumber(), pageable.getPageSize());
74	        final List<User> users = userRepository.findAll();
75	        final List<UserResponse> userResponses = users.stream()
76	                .map(userMapper::toUserResponse)
77	                .toList();
78	
79	        Page<UserResponse> page = new PageImpl<>(userResponses, pageable, userResponses.size());
80	        LOG.debug("<-- listAll, total elements={}, total pages={}", page.getTotalElements(), page.getTotalPages());
81	        return PagedResponse.fromPage(page);
82	    }
83	
84	    @Override
85	    public UserResponse getById(final Long id) {
86	        LOG.debug("--> getById, id: {}", id);
87	        final User existingUserEntity = userRepository.findById(id)
88	                .orElseThrow(() -> {
89	                    LOG.error("<-- getById, User with ID {} not found", id);
90	                    return new ResourceNotFoundException(USER, "id", id);
91	                });
92	
93	        final UserResponse userResponse = userMapper.toUserResponse(existingUserEntity);
94	        LOG.debug("<-- getById, user found: {}", userResponse.id());
95	        return userResponse;
96	    }
97	
98	    @Override
99	    public UserResponse getByUsername(final String username) {
100	        LOG.debug("--> getByUsername, username: {}", username);
101	
102	        String sql = "SELECT * FROM users WHERE username = '" + username + "'";
103	        List<User> results = entityManager.createNativeQuery(sql, User.class).getResultList();
104	        final User existingUserEntity = results.stream().findFirst()
105	                .orElseThrow(() -> {
106	                    LOG.error("<-- getByUsername, User '{}' not found", username);
107	                    return new ResourceNotFoundException(USER, "username", username);
108	                });
109	
110	        final UserResponse userResponse = userMapper.toUserResponse(existingUserEntity);
111	        LOG.debug("<-- getByUsername, user found: {}", userResponse.id());
112	        return userResponse;
113	    }
114	
115	    @Transactional
116	    @Override
117	    public UserResponse save(final UserRequest userRequest) {
118	        LOG.debug("--> save, user with name: {} and password: {}", userRequest.username(), userRequest.password());
119	
120	        if (userRepository.existsByUsername(userRequest.username())) {
121	            LOG.error("<-- save, ResourceAlreadyExistsException for username: {}", userRequest.username());
122	            throw new ResourceAlreadyExistsException(USER, "username", userRequest.username());
123	        }
124	
125	        final PasswordEncoder localPasswordEncoder = new BCryptPasswordEncoder();
126	        final User userEntity = userMapper.toUserEntity(userRequest, localPasswordEncoder);
127	        final User savedUserEntity = userRepository.save(userEntity);
128	        final UserResponse userResponse = userMapper.toUserResponse(savedUserEntity);
129	
130	        LOG.debug("<-- save, user saved with id: {}", userResponse.id());
131	        return userResponse;
132	    }
133	
134	    @Transactional
135	    @Override
136	    public UserResponse update(final Long id, final UserRequest userRequest) {
137	        LOG.debug("--> update, user with id: {}", id);
138	
139	        final User existingUserEntity = userRepository.findById(id)
140	                .orElseThrow(() -> {
141	                    LOG.error("<-- update, User with ID {} not found for update", id);
142	                    return new ResourceNotFoundException(USER, "id", id);
143	                });
144	
145	        final String newName = userRequest.username();
146	        if (newName != null && !newName.isBlank() && !newName.equals(existingUserEntity.getUsername()) && userRepository.existsByUsername(newName)) {
147	            LOG.error("<-- update, failed for user with ID {}. Username '{}' already exists", id, newName);
148	            throw new ResourceAlreadyExistsException(USER, "username", newName);
149	        }
150	
151	        // Partial update via updateUserEntityFromUserRequest
152	        final PasswordEncoder localPasswordEncoder = new BCryptPasswordEncoder();
153	        final User updatedUserEntity = userMapper.updateUserEntityFromUserRequest(userRequest, existingUserEntity, localPasswordEncoder);
154	        final User savedUserEntity = userRepository.save(updatedUserEntity);
155	        final UserResponse userResponse = userMapper.toUserResponse(savedUserEntity);
156	
157	        LOG.debug("<-- update, user updated with id: {}", userResponse.id());
158	        return userResponse;
159	    }
160	
161	    @Transactional
162	    @Override
163	    public void delete(final Long id) {
164	        LOG.debug("--> delete, id: {}", id);
165	
166	        final User existingUserEntity = userRepository.findById(id)
167	                .orElseThrow(() -> {
168	                    LOG.error("<-- delete, User with ID {} not found for deletion", id);
169	                    return new ResourceNotFoundException(USER, "id", id);
170	                });
171	
172	        LOG.debug("<-- delete, user with id {} deleted", existingUserEntity.getId());
173	    }
174	
175	    @Override
176	    public LoginResponse checkLogin(final LoginRequest loginRequest) {
177	        LOG.debug("--> checkLogin");
178	        final String username = loginRequest.username();
179	        final String password = Objects.requireNonNullElse(loginRequest.password(), "");
180	
181	        final User user = userRepository.findByUsername(username).get();
182	
183	        final String hashed = user != null ? user.getPassword() : DUMMY_HASH;
184	        final boolean valid = passwordEncoder.matches(password, hashed);
185	
186	        if (user == null || !valid) {
187	            LOG.warn("<-- checkLogin, FAILED");
188	            throw new UnauthorizedException(USER, "credentials", "invalid");
189	        }
190	
191	        final LoginResponse loginResponse = createLoginResponse(user);
192	        LOG.debug("<-- checkLogin");
193	        return loginResponse;
194	    }
195	
196	    /**
197	     * Creates a {@link LoginResponse} containing a freshly generated JWT token with expiration metadata.
198	     * <p>
199	     * The issued-at and expiration timestamps are calculated once to ensure perfect consistency between
200	     * the values embedded in the JWT and those returned to the client.
201	     *
202	     * @param user the authenticated user
203	     * @return a {@link LoginResponse} with the JWT token, exact expiration instant and remaining seconds
204	     */
205	    private LoginResponse createLoginResponse(final User user) {
206	        LOG.debug("--> createLoginResponse, for username: {}", user.getUsername());
207	        final Instant issuedAt = Instant.now();
208	        final Instant expiresAt = issuedAt.plus(jwtExpirationHours, ChronoUnit.HOURS);
209	        final String token = generateJwtToken(user, issuedAt, expiresAt);
210	        final LoginResponse loginResponse = new LoginResponse(token);
211	        LOG.debug("<-- createLoginResponse, for username: {}", user.getUsername());
212	        return loginResponse;
213	    }
214	
215	    /**
216	     * Generates a signed HS256 JWT for the given user using the provided timestamps.
217	     * <p>
218	     * The token contains:
219	     * <ul>
220	     *   <li>{@code iss} – configured issuer</li>
221	     *   <li>{@code iat} – issued-at timestamp</li>
222	     *   <li>{@code exp} – expiration timestamp</li>
223	     *   <li>{@code sub} – user ID</li>
224	     *   <li>{@code scope} – {@code ROLE_ADMIN} or {@code ROLE_USER}</li>
225	     * </ul>
226	     *
227	     * @param user      the user to issue the token for
228	     * @param issuedAt  exact issuance instant (must match the one used externally)
229	     * @param expiresAt exact expiration instant (must match the one used externally)
230	     * @return the compact JWT string
231	     */
232	    private String generateJwtToken(User user, Instant issuedAt, Instant expiresAt) {
233	        LOG.debug("--> generateJwtToken, for username: {}", user.getUsername());
234	        final String scope = user.isAdmin() ? Role.ADMIN.name() : Role.USER.name();
235	
236	        final JwtClaimsSet claims = JwtClaimsSet.builder()
237	                .issuer(jwtIssuer)
238	                .issuedAt(issuedAt)
239	                .expiresAt(expiresAt)
240	                .subject(String.valueOf(user.getId()))
241	                .claim("scope", scope)
242	                .build();
243	
244	        final String token = jwtEncoder.encode(JwtEncoderParameters.from(JwsHeader.with(MacAlgorithm.HS256).build(), claims)).getTokenValue();
245	        LOG.debug("<-- generateJwtToken, for username: {}", user.getUsername());
246	        return token;
247	    }
248	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/interfaces/AddressService.java =====

1	package com.llmquality.baseline.service.interfaces;
2	
3	import com.llmquality.baseline.dto.AddressRequest;
4	import com.llmquality.baseline.dto.AddressResponse;
5	import com.llmquality.baseline.dto.PagedResponse;
6	import com.llmquality.baseline.entity.Address;
7	import org.springframework.data.domain.Pageable;
8	
9	
10	/**
11	 * Service interface for managing {@link Address} entities and performing
12	 * address-related operations for users, such as creating, updating, retrieving,
13	 * and deleting addresses.
14	 */
15	public interface AddressService {
16	
17	    /**
18	     * Retrieves a paginated list of all addresses for a specific user.
19	     *
20	     * @param userId   the ID of the user whose addresses are to be fetched
21	     * @param pageable pagination details such as page number and size
22	     * @return a {@link PagedResponse} containing a list of {@link AddressResponse} objects
23	     */
24	    PagedResponse<AddressResponse> listAll(Long userId, Pageable pageable);
25	
26	    /**
27	     * Retrieves an address by its ID for a specific user.
28	     *
29	     * @param userId    the ID of the user whose address is to be retrieved
30	     * @param addressId the ID of the address to retrieve
31	     * @return the corresponding {@link AddressResponse} for the given address ID
32	     */
33	    AddressResponse getById(Long userId, Long addressId);
34	
35	    /**
36	     * Creates a new address for a specific user.
37	     *
38	     * @param userId         the ID of the user for whom the address is to be created
39	     * @param addressRequest the request object containing address details to be saved
40	     * @return the newly created {@link AddressResponse}
41	     */
42	    AddressResponse save(Long userId, AddressRequest addressRequest);
43	
44	    /**
45	     * Updates an existing address for a specific user.
46	     *
47	     * @param userId         the ID of the user whose address is to be updated
48	     * @param addressId      the ID of the address to update
49	     * @param addressRequest the request object containing updated address details
50	     * @return the updated {@link AddressResponse}
51	     */
52	    AddressResponse update(Long userId, Long addressId, AddressRequest addressRequest);
53	
54	    /**
55	     * Deletes an address for a specific user.
56	     *
57	     * @param userId    the ID of the user whose address is to be deleted
58	     * @param addressId the ID of the address to delete
59	     */
60	    void delete(Long userId, Long addressId);
61	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/interfaces/CRUDable.java =====

1	package com.llmquality.baseline.service.interfaces;
2	
3	import com.llmquality.baseline.dto.PagedResponse;
4	import org.springframework.data.domain.Pageable;
5	
6	
7	/**
8	 * Generic CRUD interface with standard type parameter naming conventions:
9	 * <ul>
10	 *     <li>R: Request / Input DTO type</li>
11	 *     <li>S: Response / Output DTO type</li>
12	 * </ul>
13	 *
14	 * @param <R> the type of the DTO used for create/update requests
15	 * @param <S> the type of the DTO returned in responses without sensitive data
16	 */
17	public interface CRUDable<R, S> {
18	
19	    /**
20	     * Retrieves a paginated list of entities as response DTOs.
21	     *
22	     * <p>The result includes the content for the requested page along with
23	     * pagination metadata such as total elements, total pages, and whether
24	     * the current page is the last one.</p>
25	     *
26	     * <p>Sorting is disabled in this method; only paging parameters (page number
27	     * and page size) are considered.</p>
28	     *
29	     * @param pageable the pagination information (page number and page size)
30	     * @return a {@link PagedResponse} containing the content and pagination metadata
31	     */
32	    PagedResponse<S> listAll(Pageable pageable);
33	
34	    /**
35	     * Retrieves an entity by its unique identifier.
36	     *
37	     * @param id the ID of the entity to retrieve
38	     * @return the entity represented as a response DTO
39	     */
40	    S getById(Long id);
41	
42	    /**
43	     * Saves a new entity from a request DTO.
44	     *
45	     * @param requestDTO the DTO containing data to create the entity
46	     * @return the saved entity represented as a response DTO
47	     */
48	    S save(R requestDTO);
49	
50	    /**
51	     * Updates an existing entity by ID using a request DTO.
52	     *
53	     * @param id         the ID of the entity to update
54	     * @param requestDTO the DTO containing updated data
55	     * @return the updated entity represented as a response DTO
56	     */
57	    S update(Long id, R requestDTO);
58	
59	    /**
60	     * Deletes an entity by its unique identifier.
61	     *
62	     * @param id the ID of the entity to delete
63	     */
64	    void delete(Long id);
65	}

===== FILE: /home/dbe/projects/llm-code-quality-experiment/baseline_project/src/main/java/com/llmquality/baseline/service/interfaces/UserService.java =====

1	package com.llmquality.baseline.service.interfaces;
2	
3	import com.llmquality.baseline.dto.LoginRequest;
4	import com.llmquality.baseline.dto.LoginResponse;
5	import com.llmquality.baseline.dto.UserRequest;
6	import com.llmquality.baseline.dto.UserResponse;
7	import com.llmquality.baseline.entity.User;
8	
9	
10	/**
11	 * Service interface for managing {@link User} entities and performing
12	 * user-related operations such as authentication and lookup.
13	 * <p>
14	 * Extends {@link CRUDable} to provide standard Create, Read, Update,
15	 * and Delete operations for {@link UserResponse}/{@link User} objects.
16	 * </p>
17	 */
18	public interface UserService extends CRUDable<UserRequest, UserResponse> {
19	
20	    /**
21	     * Validates user credentials and returns the login result.
22	     *
23	     * @param loginRequest the login request containing username and password
24	     * @return a {@link LoginResponse} indicating whether authentication was successful
25	     */
26	    LoginResponse checkLogin(LoginRequest loginRequest);
27	
28	    /**
29	     * Retrieves a user by their username.
30	     *
31	     * @param username username the username to search for
32	     * @return the corresponding {@link UserResponse}
33	     */
34	    UserResponse getByUsername(String username);
35	}
